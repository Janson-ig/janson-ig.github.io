<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>算法 on Janson&#39;s Blog</title>
        <link>http://www.jansonblog.com/categories/%E7%AE%97%E6%B3%95/</link>
        <description>Recent content in 算法 on Janson&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Thu, 03 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="http://www.jansonblog.com/categories/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>KMP算法（字符串匹配算法）</title>
        <link>http://www.jansonblog.com/p/kmp/</link>
        <pubDate>Thu, 03 Nov 2022 00:00:00 +0000</pubDate>
        
        <guid>http://www.jansonblog.com/p/kmp/</guid>
        <description>&lt;img src="http://www.jansonblog.com/p/kmp/1.png" alt="Featured image of post KMP算法（字符串匹配算法）" /&gt;&lt;h2 id=&#34;kmpknuth-morris-pratt算法&#34;&gt;KMP(Knuth-Morris-Pratt)算法：&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt; 字符串查找算法（简称为KMP算法）可在一个字符串S内查找一个词W的出现位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能的开始位置，此算法利用这一特性以避免重重复查找之前出现的字符。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 我对MKP的认识：其归属于DP问题，核心的思想在于对要查找的字符串进行处理——寻找最长的前缀。然后通过记忆化数组的方式，跳过不可能成功匹配的字符串位置，从下一个可能的位置进行搜索。利用要查找字符串的特性，利用其前缀和后缀的共同部分来简化搜索过程。&lt;/p&gt;
&lt;h2 id=&#34;算法原理&#34;&gt;算法原理：&lt;/h2&gt;
&lt;p&gt; 简单的暴力搜索无非就是从每个可能的index开始，与要查找的字符串进行比较。
 而KMP则会跳过已经匹配的部分，以维基百科的说明为例，简单概括过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;要查找的字符串W=&amp;ldquo;ABCDABD&amp;rdquo;，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;给定字符串S=&amp;ldquo;ABC ABCDAB ABCDABCDABDE&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为例说明查找过程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;S: &lt;strong&gt;ABC&lt;/strong&gt; ABCDAB ABCDABCDABDE&lt;br&gt;
W: &lt;strong&gt;ABC&lt;/strong&gt;DABD&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;S[3]（=&amp;rsquo; &amp;rsquo;)与W[3]（=&amp;lsquo;D&amp;rsquo;）不匹配，所以跳过；从S[4]开始，与W[0]进行比较。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;S:ABC &lt;strong&gt;ABCDAB&lt;/strong&gt; ABCDABCDABDE&lt;br&gt;
W:&lt;strong&gt;ABCDAB&lt;/strong&gt;D&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;从S[4]开始比较，当位于S[10]（=&amp;rsquo; &amp;rsquo;）时，与W对应的字符不匹配；但是此时可以注意到，&amp;quot;&lt;strong&gt;AB&lt;/strong&gt;&amp;ldquo;在“ABCD&lt;strong&gt;AB&lt;/strong&gt;&amp;ldquo;的头尾处均有出现——这意味着，尾部的“AB”可以作为下一次比较的起点。&lt;/li&gt;
&lt;li&gt;所以下次从index = 8的位置：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;S:ABC ABCD&lt;strong&gt;A&lt;/strong&gt;B ABCDABCDABDE&lt;br&gt;
W:ABCD&lt;strong&gt;A&lt;/strong&gt;BD&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;即&lt;strong&gt;A&lt;/strong&gt;开始进行匹配。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;应用题目实战&#34;&gt;应用题目实战:&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/&#34;  title=&#34;LeetCode 28. Find the Index of the First Occurrence in a String&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LeetCode 28. Find the Index of the First Occurrence in a String&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目实战日后补充说明&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同时推荐一个算法可视化工具：&lt;br&gt;
&lt;a class=&#34;link&#34; href=&#34;https://algorithm-visualizer.org/dynamic-programming/knuth-morris-pratts-string-search&#34;  title=&#34;algorithm-visualizer_KMP&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;algorithm-visualizer_KMP&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如有遗漏或错误，欢迎补充纠正&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        <item>
        <title>动态规划(Dynamic programming)问题解法</title>
        <link>http://www.jansonblog.com/p/post1/</link>
        <pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate>
        
        <guid>http://www.jansonblog.com/p/post1/</guid>
        <description>&lt;img src="http://www.jansonblog.com/p/post1/PascalTriangleFibanacci.jpg" alt="Featured image of post 动态规划(Dynamic programming)问题解法" /&gt;&lt;p&gt;动态规划实现有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自下而上        (制表)&lt;/li&gt;
&lt;li&gt;自上而下        (记忆化)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;自下而上&#34;&gt;自下而上&lt;/h2&gt;
&lt;p&gt;自下而上是通过 &lt;em&gt;迭代&lt;/em&gt;  实现的&lt;/p&gt;
&lt;p&gt;以&lt;strong&gt;斐波那契数列&lt;/strong&gt;为例，F(0)=0, F(1)=1。通过F(0)和F(1)计算F(2)，然后使用计算结果计算F(3)…&lt;/p&gt;
&lt;p&gt;以此类推，一直计算F(n)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 伪代码如下:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;F = array of length (n + 1)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;F[0] = 0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;F[1] = 1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;for i from 2 to n:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    F[i] = F[i - 1] + F[i - 2]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;自上而下&#34;&gt;自上而下&lt;/h2&gt;
&lt;p&gt;自上而下通过 &lt;em&gt;递归&lt;/em&gt; 实现，并且通过 &lt;em&gt;记忆化&lt;/em&gt; 提高效率(之后解释记忆化概念)&lt;/p&gt;
&lt;p&gt;如果我们想知道斐波那契数列F(n)，需要找到F(n-1)和F(n-2)…通过递归求出F(0)和F(1)&lt;/p&gt;
&lt;p&gt;缺点也很明显，在计算中存在大量的 重复计算 ，导致效率不高&lt;/p&gt;
&lt;p&gt;而解决方法也很简单，用空间换时间，也就是 &lt;em&gt;记忆化&lt;/em&gt; ：将函数调用的结果存储在哈希图或数组中，这样当再次进行相同的函数调用时，我们可以简单地返回记忆的结果，而不是重新计算结果。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;//伪代码如下:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;memo = hashmap
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Function F(integer i):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    if i is 0 or 1: 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return i
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    if i doesn&amp;#39;t exist in memo:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        memo[i] = F(i - 1) + F(i - 2)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    return memo[i]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;所以，这两个算法哪个更好呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DP(动态规划问题)可以用任意一种方法实现&lt;/p&gt;
&lt;p&gt;每个方法都有一个突出的优点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自下而上的运行速度更快    (递归效率低)&lt;/li&gt;
&lt;li&gt;自上而下的实现更简单        (因为对于递归来说，我们不用在意子问题的逻辑顺序，而对于自下而上的方法来说，我们需要解决子问题的逻辑顺序)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;比较简单而且经典的题目：&lt;a class=&#34;link&#34; href=&#34;https://leetcode.cn/problems/unique-paths/&#34;  title=&#34;《力扣 62.不同路径》&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《力扣 62.不同路径》&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学习资料如下:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode.com/explore/learn/card/dynamic-programming/630/an-introduction-to-dynamic-programming/4035/&#34;  title=&#34;Explore - LeetCode&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Explore - LeetCode&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如有遗漏或错误，欢迎补充纠正&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
    </channel>
</rss>
