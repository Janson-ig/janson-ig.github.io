<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>算法 on Janson's Blog</title><link>http://www.jansonblog.com/categories/%E7%AE%97%E6%B3%95/</link><description>Recent content in 算法 on Janson's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 23 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="http://www.jansonblog.com/categories/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>格雷码（Gray code）</title><link>http://www.jansonblog.com/p/graycode/</link><pubDate>Thu, 23 Feb 2023 00:00:00 +0000</pubDate><guid>http://www.jansonblog.com/p/graycode/</guid><description>&lt;img src="http://www.jansonblog.com/p/graycode/1.jpg" alt="Featured image of post 格雷码（Gray code）" />&lt;h2 id="简介--原理">简介 &amp;amp; 原理
&lt;/h2>&lt;p> 格雷码（Gray code）是由贝尔实验室的Frank Gray在1940年提出，用于在PCM（脉冲编码调变）方法传送讯号时防止出错。&lt;br>
 格雷码是一个数列集合，相邻两数间&lt;strong>只有一个位元&lt;/strong>改变，为无权数码，且格雷码的顺序不是唯一的。&lt;br>
 原理：&lt;/p>
&lt;blockquote>
&lt;p> 传统的二进位系统，例如数字3的表示法为011，要切换为邻近的数字4，也就是100时，装置中的三个位元都得要转换，因此于未完全转换的过程时装置会经历短暂的，010,001,101,110,111等其中数种状态，也就是代表着2、1、5、6、7，因此此种数字编码方法于邻近数字转换时有比较大的误差可能范围。
格雷码的发明即是用来将误差之可能性缩减至最小，编码的方式定义为每个邻近数字都只相差一个位元，因此也称为最小差异码，可以使装置做数字步进时只更动最少的位元数以提高稳定性。&lt;/p>&lt;/blockquote>
&lt;h2 id="代码实现">代码实现
&lt;/h2>&lt;p> 用&lt;code>G&lt;/code>代表格雷码：&lt;br>
 例如3位数的格雷码序列为：&lt;code>000&lt;/code>,&lt;code>001&lt;/code>,&lt;code>011&lt;/code>,&lt;code>010&lt;/code>,&lt;code>110&lt;/code>,&lt;code>111&lt;/code>,&lt;code>101&lt;/code>,&lt;code>100&lt;/code>。&lt;code>111&lt;/code>可以用&lt;code>G(4) = 6&lt;/code>来表示。&lt;/p>
&lt;p> &lt;em>&lt;strong>公式：&lt;/strong>&lt;/em>&lt;code>G(n) = n ^ (n &amp;gt;&amp;gt; 1)&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">int g (int n) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return n ^ (n &amp;gt;&amp;gt; 1);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="例题">例题
&lt;/h3>&lt;p>&lt;a class="link" href="https://leetcode.com/problems/circular-permutation-in-binary-representation/description/" title="1238. Circular Permutation in Binary Representation"
target="_blank" rel="noopener"
>[medium]1238. Circular Permutation in Binary Representation&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>如有遗漏或错误，欢迎补充纠正&lt;/p>&lt;/blockquote></description></item><item><title>GCD算法（最大公因数算法）</title><link>http://www.jansonblog.com/p/gcd/</link><pubDate>Wed, 01 Feb 2023 00:00:00 +0000</pubDate><guid>http://www.jansonblog.com/p/gcd/</guid><description>&lt;img src="http://www.jansonblog.com/p/gcd/1.jpg" alt="Featured image of post GCD算法（最大公因数算法）" />&lt;h2 id="欧几里得算法辗转相除法">欧几里得算法（辗转相除法）
&lt;/h2>&lt;h3 id="递归实现">递归实现
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">gcd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">){&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">gcd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="迭代实现">迭代实现
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">gcd&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tmp&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">tmp&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="例题">例题
&lt;/h3>&lt;p>&lt;a class="link" href="https://leetcode.com/problems/greatest-common-divisor-of-strings/description/" title="1071. Greatest Common Divisor of Strings"
target="_blank" rel="noopener"
>[easy]1071. Greatest Common Divisor of Strings&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>如有遗漏或错误，欢迎补充纠正&lt;/p>&lt;/blockquote></description></item><item><title>并查集（Union-find）[Java]</title><link>http://www.jansonblog.com/p/union-find/</link><pubDate>Mon, 14 Nov 2022 00:00:00 +0000</pubDate><guid>http://www.jansonblog.com/p/union-find/</guid><description>&lt;img src="http://www.jansonblog.com/p/union-find/1.jpg" alt="Featured image of post 并查集（Union-find）[Java]" />&lt;h2 id="什么是并查集">什么是并查集？
&lt;/h2>&lt;blockquote>
&lt;p>  并查集(Disjoint-set data structure)是一种数据结构，用于解决&lt;strong>不交集&lt;/strong>问题的合并及查询问题。它还有几个英文名叫：Union-find data structure / merge–find set(中文就是：合并-查找数据结构)。&lt;/p>&lt;/blockquote>
&lt;p>  为什么叫&lt;strong>合并-查询数据结构&lt;/strong>？因为并查集有三个功能：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>添加&lt;/strong>&lt;/li>
&lt;li>&lt;strong>合并&lt;/strong>&lt;/li>
&lt;li>&lt;strong>查询&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>  以维基百科的例子为例:&lt;/p>
&lt;blockquote>
&lt;p>现在有数字1-8共八个元素，每个元素是一个集合：
&lt;img src="http://www.jansonblog.com/p/union-find/2-1.jpg"
width="1920"
height="175"
srcset="http://www.jansonblog.com/p/union-find/2-1_hu_610f81d7df680547.jpg 480w, http://www.jansonblog.com/p/union-find/2-1_hu_5ca2df5dc054f209.jpg 1024w"
loading="lazy"
alt="2-1"
class="gallery-image"
data-flex-grow="1097"
data-flex-basis="2633px"
>&lt;/p>
&lt;p>&lt;strong>合并&lt;/strong>操作几次后，一些集合合并到了一起：
&lt;img src="http://www.jansonblog.com/p/union-find/2-2.jpg"
width="1920"
height="175"
srcset="http://www.jansonblog.com/p/union-find/2-2_hu_6f504a0c1c09678f.jpg 480w, http://www.jansonblog.com/p/union-find/2-2_hu_f53b4c12088a3352.jpg 1024w"
loading="lazy"
alt="2-2"
class="gallery-image"
data-flex-grow="1097"
data-flex-basis="2633px"
>&lt;/p>&lt;/blockquote>
&lt;p>  这就是并查集，其实很简单。其主要的作用就是&lt;strong>合并&lt;/strong>和&lt;strong>查找&lt;/strong>。&lt;br>
  其最常见的实现是不交集森林。但是为了方便解释，接下来用一个数组实现的力扣题目来说明。&lt;/p>
&lt;h2 id="力扣990题">&lt;a class="link" href="https://leetcode.cn/problems/satisfiability-of-equality-equations/" title="力扣990.等式方程的可满足性"
target="_blank" rel="noopener"
>力扣990题&lt;/a>
&lt;/h2>&lt;blockquote>
&lt;p>题目：&lt;strong>等式方程的可满足性&lt;/strong>&lt;/p>
&lt;p> 给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：&amp;ldquo;a==b&amp;rdquo; 或 &amp;ldquo;a!=b&amp;rdquo;。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。&lt;br>
 只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。&lt;/p>&lt;/blockquote>
&lt;p>示例1：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>输入：&lt;/strong> [&amp;ldquo;a==b&amp;rdquo;,&amp;ldquo;b!=a&amp;rdquo;]&lt;br>
&lt;strong>输出：&lt;/strong> false&lt;br>
&lt;strong>解释：&lt;/strong> 如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。&lt;/p>&lt;/blockquote>
&lt;p>示例2：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>输入：&lt;/strong> [&amp;ldquo;b==a&amp;rdquo;,&amp;ldquo;a==b&amp;rdquo;]&lt;br>
&lt;strong>输出：&lt;/strong> true&lt;br>
&lt;strong>解释：&lt;/strong> 我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。&lt;/p>&lt;/blockquote>
&lt;h2 id="题解java-感谢lee215大佬提供的题解">题解[Java] (感谢Lee215大佬提供的题解)：
&lt;/h2>&lt;p> 990这道题由于最大只有26个小写字母，所以可以使用数组来实现&lt;strong>并查集&lt;/strong>。&lt;br>
 具体思路（并查集的三个功能）：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>添加：&lt;/strong> 建立大小为26的int数组,名为uf；得到大小为26的数组，并让每个位置对应一个英文字母，即：&lt;br>
 从&lt;code>'a'-'z'&lt;/code>对应&lt;code>uf[0] - uf[25]&lt;/code>，即：&lt;code>uf[0] = 0&lt;/code>，&lt;code>uf[1] = 1&lt;/code>……&lt;code>uf[25]=25&lt;/code>分别代表26个字母，也得到了26个集合。&lt;/li>
&lt;li>&lt;strong>合并：&lt;/strong> 将符合 &lt;code>==&lt;/code>关系的合并到一个集合中，实现：&lt;br>
  例如，我们想将&lt;code>'a'&lt;/code>对应的集合&lt;code>uf[0]&lt;/code>与&lt;code>'b'&lt;/code>对应的集合&lt;code>uf[1]&lt;/code>合并，只需让：&lt;code>uf[0] = 1&lt;/code>&lt;br>
  这样当我们查看&lt;code>'a'&lt;/code>对应的&lt;code>uf[0]&lt;/code>的值时，即可发现集合&lt;code>'a'&lt;/code>与集合&lt;code>'b'&lt;/code>是合并的。&lt;/li>
&lt;li>&lt;strong>查找：&lt;/strong> 查找只需要从数组uf的一个位置开始，便可以知道该位置对应的字母与哪些字母合并过。&lt;/li>
&lt;/ol>
&lt;p> 在建立并查集后，本题只需要查看所有&lt;code>!=&lt;/code>关系中的字母，是否在并查集中被合并到了一个集合。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">class&lt;/span> &lt;span class="nc">Solution&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">uf&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">new&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">26&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">public&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">boolean&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">equationsPossible&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">equations&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//添加并查集；uf[0]到uf[25]分别对应从&amp;#39;a&amp;#39;到&amp;#39;z&amp;#39;的26个小写字母&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">26&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">){&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">uf&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//合并；合并“==”关系的字母：使用find()方法查询到集合的最后一个字母，将其合并&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">equations&lt;/span>&lt;span class="p">){&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">charAt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">&amp;#39;=&amp;#39;&lt;/span>&lt;span class="p">){&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">uf&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">find&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">charAt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">&amp;#39;a&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">find&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">charAt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">3&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">&amp;#39;a&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//遍历并查集，使用find()方法找到每个集合最尾端的字母，&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//判断最尾端字母是否相同来判断“!=”两边的字母是否位于一个集合内&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">equations&lt;/span>&lt;span class="p">){&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">charAt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">&amp;#39;!&amp;#39;&lt;/span>&lt;span class="p">){&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uf&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">find&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">charAt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">&amp;#39;a&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">uf&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">find&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="na">charAt&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">3&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="sc">&amp;#39;a&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">false&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">//查找；寻找属于同一集合的最尾端的字母，将其返回&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">private&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nf">find&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="p">){&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uf&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="p">){&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">uf&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">find&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">uf&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="k">return&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">uf&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">idx&lt;/span>&lt;span class="o">]&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>如有遗漏或错误，欢迎补充纠正&lt;/p>&lt;/blockquote></description></item><item><title>KMP算法（字符串匹配算法）</title><link>http://www.jansonblog.com/p/kmp/</link><pubDate>Thu, 03 Nov 2022 00:00:00 +0000</pubDate><guid>http://www.jansonblog.com/p/kmp/</guid><description>&lt;img src="http://www.jansonblog.com/p/kmp/1.png" alt="Featured image of post KMP算法（字符串匹配算法）" />&lt;h2 id="kmpknuth-morris-pratt算法">KMP(Knuth-Morris-Pratt)算法：
&lt;/h2>&lt;blockquote>
&lt;p> 字符串查找算法（简称为KMP算法）可在一个字符串S内查找一个词W的出现位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能的开始位置，此算法利用这一特性以避免重重复查找之前出现的字符。&lt;/p>&lt;/blockquote>
&lt;p> 我对MKP的认识：其归属于DP问题，核心的思想在于对要查找的字符串进行处理——寻找最长的前缀。然后通过记忆化数组的方式，跳过不可能成功匹配的字符串位置，从下一个可能的位置进行搜索。利用要查找字符串的特性，利用其前缀和后缀的共同部分来简化搜索过程。&lt;/p>
&lt;h2 id="算法原理">算法原理：
&lt;/h2>&lt;p> 简单的暴力搜索无非就是从每个可能的index开始，与要查找的字符串进行比较。
 而KMP则会跳过已经匹配的部分，以维基百科的说明为例，简单概括过程：&lt;/p>
&lt;ul>
&lt;li>
&lt;blockquote>
&lt;p>要查找的字符串W=&amp;ldquo;ABCDABD&amp;rdquo;，&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;blockquote>
&lt;p>给定字符串S=&amp;ldquo;ABC ABCDAB ABCDABCDABDE&amp;rdquo;&lt;/p>&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;p>为例说明查找过程：&lt;/p>
&lt;blockquote>
&lt;p>S: &lt;strong>ABC&lt;/strong> ABCDAB ABCDABCDABDE&lt;br>
W: &lt;strong>ABC&lt;/strong>DABD&lt;/p>&lt;/blockquote>
&lt;ul>
&lt;li>S[3]（=&amp;rsquo; &amp;rsquo;)与W[3]（=&amp;lsquo;D&amp;rsquo;）不匹配，所以跳过；从S[4]开始，与W[0]进行比较。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>S:ABC &lt;strong>ABCDAB&lt;/strong> ABCDABCDABDE&lt;br>
W:&lt;strong>ABCDAB&lt;/strong>D&lt;/p>&lt;/blockquote>
&lt;ul>
&lt;li>从S[4]开始比较，当位于S[10]（=&amp;rsquo; &amp;rsquo;）时，与W对应的字符不匹配；但是此时可以注意到，&amp;quot;&lt;strong>AB&lt;/strong>&amp;ldquo;在“ABCD&lt;strong>AB&lt;/strong>&amp;ldquo;的头尾处均有出现——这意味着，尾部的“AB”可以作为下一次比较的起点。&lt;/li>
&lt;li>所以下次从index = 8的位置：&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>S:ABC ABCD&lt;strong>A&lt;/strong>B ABCDABCDABDE&lt;br>
W:ABCD&lt;strong>A&lt;/strong>BD&lt;/p>&lt;/blockquote>
&lt;ul>
&lt;li>即&lt;strong>A&lt;/strong>开始进行匹配。&lt;/li>
&lt;/ul>
&lt;h2 id="应用题目实战">应用题目实战:
&lt;/h2>&lt;p>&lt;a class="link" href="https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/" title="LeetCode 28. Find the Index of the First Occurrence in a String"
target="_blank" rel="noopener"
>LeetCode 28. Find the Index of the First Occurrence in a String&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>题目实战日后补充说明&lt;/p>&lt;/blockquote>
&lt;p>同时推荐一个算法可视化工具：&lt;br>
&lt;a class="link" href="https://algorithm-visualizer.org/dynamic-programming/knuth-morris-pratts-string-search" title="algorithm-visualizer_KMP"
target="_blank" rel="noopener"
>algorithm-visualizer_KMP&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>如有遗漏或错误，欢迎补充纠正&lt;/p>&lt;/blockquote></description></item><item><title>动态规划(Dynamic programming)问题解法</title><link>http://www.jansonblog.com/p/dp/</link><pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate><guid>http://www.jansonblog.com/p/dp/</guid><description>&lt;img src="http://www.jansonblog.com/p/dp/PascalTriangleFibanacci.jpg" alt="Featured image of post 动态规划(Dynamic programming)问题解法" />&lt;p>动态规划实现有两种方法：&lt;/p>
&lt;ol>
&lt;li>自下而上        (制表)&lt;/li>
&lt;li>自上而下        (记忆化)&lt;/li>
&lt;/ol>
&lt;h2 id="自下而上">自下而上
&lt;/h2>&lt;p>自下而上是通过 &lt;em>迭代&lt;/em> 实现的&lt;/p>
&lt;p>以&lt;strong>斐波那契数列&lt;/strong>为例，F(0)=0, F(1)=1。通过F(0)和F(1)计算F(2)，然后使用计算结果计算F(3)…&lt;/p>
&lt;p>以此类推，一直计算F(n)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">// 伪代码如下:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">F = array of length (n + 1)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">F[0] = 0
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">F[1] = 1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">for i from 2 to n:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> F[i] = F[i - 1] + F[i - 2]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="自上而下">自上而下
&lt;/h2>&lt;p>自上而下通过 &lt;em>递归&lt;/em> 实现，并且通过 &lt;em>记忆化&lt;/em> 提高效率(之后解释记忆化概念)&lt;/p>
&lt;p>如果我们想知道斐波那契数列F(n)，需要找到F(n-1)和F(n-2)…通过递归求出F(0)和F(1)&lt;/p>
&lt;p>缺点也很明显，在计算中存在大量的 重复计算 ，导致效率不高&lt;/p>
&lt;p>而解决方法也很简单，用空间换时间，也就是 &lt;em>记忆化&lt;/em> ：将函数调用的结果存储在哈希图或数组中，这样当再次进行相同的函数调用时，我们可以简单地返回记忆的结果，而不是重新计算结果。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">//伪代码如下:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">memo = hashmap
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Function F(integer i):
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if i is 0 or 1:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return i
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if i doesn&amp;#39;t exist in memo:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> memo[i] = F(i - 1) + F(i - 2)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return memo[i]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="总结">总结
&lt;/h2>&lt;p>&lt;strong>所以，这两个算法哪个更好呢？&lt;/strong>&lt;/p>
&lt;p>DP(动态规划问题)可以用任意一种方法实现&lt;/p>
&lt;p>每个方法都有一个突出的优点:&lt;/p>
&lt;ul>
&lt;li>自下而上的运行速度更快    (递归效率低)&lt;/li>
&lt;li>自上而下的实现更简单        (因为对于递归来说，我们不用在意子问题的逻辑顺序，而对于自下而上的方法来说，我们需要解决子问题的逻辑顺序)&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>比较简单而且经典的题目：&lt;a class="link" href="https://leetcode.cn/problems/unique-paths/" title="《力扣 62.不同路径》"
target="_blank" rel="noopener"
>《力扣 62.不同路径》&lt;/a>&lt;/strong>&lt;/p>
&lt;p>学习资料如下:&lt;/p>
&lt;p>&lt;a class="link" href="https://leetcode.com/explore/learn/card/dynamic-programming/630/an-introduction-to-dynamic-programming/4035/" title="Explore - LeetCode"
target="_blank" rel="noopener"
>Explore - LeetCode&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>如有遗漏或错误，欢迎补充纠正&lt;/p>&lt;/blockquote></description></item></channel></rss>