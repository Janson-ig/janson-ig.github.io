<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>学习笔记 on Janson&#39;s Blog</title>
        <link>http://www.jansonblog.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
        <description>Recent content in 学习笔记 on Janson&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Fri, 27 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="http://www.jansonblog.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>动态规划(Dynamic programming)问题解法</title>
        <link>http://www.jansonblog.com/p/post1/</link>
        <pubDate>Fri, 27 May 2022 00:00:00 +0000</pubDate>
        
        <guid>http://www.jansonblog.com/p/post1/</guid>
        <description>&lt;img src="http://www.jansonblog.com/p/post1/PascalTriangleFibanacci.jpg" alt="Featured image of post 动态规划(Dynamic programming)问题解法" /&gt;&lt;p&gt;动态规划实现有两种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自下而上        (制表)&lt;/li&gt;
&lt;li&gt;自上而下        (记忆化)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;自下而上&#34;&gt;自下而上&lt;/h2&gt;
&lt;p&gt;自下而上是通过 &lt;em&gt;迭代&lt;/em&gt;  实现的&lt;/p&gt;
&lt;p&gt;以&lt;strong&gt;斐波那契数列&lt;/strong&gt;为例，F(0)=0, F(1)=1。通过F(0)和F(1)计算F(2)，然后使用计算结果计算F(3)…&lt;/p&gt;
&lt;p&gt;以此类推，一直计算F(n)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 伪代码如下:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;F = array of length (n + 1)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;F[0] = 0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;F[1] = 1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;for i from 2 to n:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    F[i] = F[i - 1] + F[i - 2]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;自上而下&#34;&gt;自上而下&lt;/h2&gt;
&lt;p&gt;自上而下通过 &lt;em&gt;递归&lt;/em&gt; 实现，并且通过 &lt;em&gt;记忆化&lt;/em&gt; 提高效率(之后解释记忆化概念)&lt;/p&gt;
&lt;p&gt;如果我们想知道斐波那契数列F(n)，需要找到F(n-1)和F(n-2)…通过递归求出F(0)和F(1)&lt;/p&gt;
&lt;p&gt;缺点也很明显，在计算中存在大量的 重复计算 ，导致效率不高&lt;/p&gt;
&lt;p&gt;而解决方法也很简单，用空间换时间，也就是 &lt;em&gt;记忆化&lt;/em&gt; ：将函数调用的结果存储在哈希图或数组中，这样当再次进行相同的函数调用时，我们可以简单地返回记忆的结果，而不是重新计算结果。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;//伪代码如下:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;memo = hashmap
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Function F(integer i):
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    if i is 0 or 1: 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return i
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    if i doesn&amp;#39;t exist in memo:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        memo[i] = F(i - 1) + F(i - 2)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    return memo[i]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;所以，这两个算法哪个更好呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;DP(动态规划问题)可以用任意一种方法实现&lt;/p&gt;
&lt;p&gt;每个方法都有一个突出的优点:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自下而上的运行速度更快    (递归效率低)&lt;/li&gt;
&lt;li&gt;自上而下的实现更简单        (因为对于递归来说，我们不用在意子问题的逻辑顺序，而对于自下而上的方法来说，我们需要解决子问题的逻辑顺序)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;比较简单而且经典的题目：&lt;a class=&#34;link&#34; href=&#34;https://leetcode.cn/problems/unique-paths/&#34;  title=&#34;《力扣 62.不同路径》&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《力扣 62.不同路径》&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学习资料如下:&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode.com/explore/learn/card/dynamic-programming/630/an-introduction-to-dynamic-programming/4035/&#34;  title=&#34;Explore - LeetCode&#34;
     target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Explore - LeetCode&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如有遗漏或错误，欢迎补充纠正&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        </item>
        
    </channel>
</rss>
