[{"content":"近况 两个月没有更新博客，因为什么都没有做，把最近的一些事，漫无目的的记录下来。随缘配图，我把这篇作为最近内心的一片幽静之地，在混乱中整理思绪，毕竟这是我的博客，我不要管别人看起来如何。\n1.力扣 力扣依旧在每日刷题，现在基本上看到题可以判断出是什么题型，但是最近对于做题仿佛失去了一些思考。明知道只做出来是不对的，但是还是懒得去思考。或许是因为研究过于不顺，导致自己每天没有余力去探索。\n跟狗人和阿毛一起报名了力扣的一个什么比赛，六道题目，好像一个人四个小时。我和阿毛10分钟不到做完了1，2题，后面知道是dp但是没想出公式，加上那天后背的粉瘤爆炸，下午不得不赶在医院关门前去诊所，最后排名也就只能1000+的样子。\n好消息在比赛赚了1k积分，终于能换力扣全家桶了。但是，只能等回国再换，而我又什么时候可以回国呢。心中虽然有了回国的计划，但是最近研究的种种不顺，可能只能放弃寒假回国的计划，毕竟学会发表顺利毕业才是现阶段最重要的事。\n2.学习 LoRa网关真的很难搞，研究室没有人能帮，只能自己硬着头皮，顶着压力一点一点来。\n今天抱着试试的态度跟一个台湾的公司联络了一下，居然一个小时就收到了回信，虽然很简短，但是给了看起来有用的文档。看了一眼文档，前路漫漫，比想象中的要困难。进度一拖再拖，没有进展。\n3.掘金 最大的收获应该是认识了掘金的小伙伴。安安，小安，小鱼，鑫，master。一群五湖四海的人就因为一场游戏比赛聚到了一起。\n其中印象最深，聊的最多的是安安。安安是莱州的老乡。安安看着外表搞笑坚强，但是自述有些抑郁。我呢？我应该并不抑郁，不过在日本留学这几年，我内心也是孤独的，我似乎能体会到她和阿毛当时考研时的孤独。她的经历我周围有很多人跟她相似，但是她是一个非常外向的人，内心痛苦会释放。\n4.独白 安安是一个让我有时候会羡慕的人，因为她知道自己喜欢什么。而我，像王小波说的那样，原文我并不记得了，大概意思是：20岁是最迷茫的年龄，因为一个人要决定自己以后做什么。\n我又想做什么呢？自学了Java或许是出于一种喜爱，又或是承诺的履行？因为好像是舅舅跟我说可以学Java，但是我可能又是羡慕大一花旗那个保研清北的学长，因为在他口中Java是那么有趣。或许我确实对Java有自己的喜爱，才能在尝试过那么多语言后选择Java。\n总之，想起来舅妈说的话：“现在的年轻人迷茫是因为可以选的路太多了，她们那个年代，没有那么多路，大家不知不觉进了一条路就坚持走到了最后”。我也尽量不去想自己的选择，做出了选择就不要后悔。\n在我内心空虚的时候，都回去看王小波的文章，因为他的经历和三观符合我的内心。\n牢骚就发到这，因为まなびLAぼ要打卡下班了！\n无论遇到什么人，我都会一直看守着内心的那块净土，直到遇到你。\n","date":"2022-10-20T00:00:00Z","image":"http://www.jansonblog.com/p/202210/1_hud19e336ace294e14e66119b0592b486d_120198_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jansonblog.com/p/202210/","title":"2022年10月20日"},{"content":" 对于我们来说，八月的主旋律是悲伤，因为答辩在八月，八月是狂欢和离别的夏天\n毕业季——给学长送行 曲学长要去LINE福冈工作了，走之前前一夜只睡了2个两小时，看着那状态实在不放心，陪他坐车到了新大阪去换乘新干线（最后还是等错了站台，改了票…）\n我跟学长都很喜欢吃咖喱，但是学长基本不喝酒\nflag！ 跟学长约定，我拿到offer或者回国之前一定会去福冈找他。\n用了很久的头像，当时是随便找的，偶然发现这个照片居然是在福冈县的神社拍的，所以去福冈也是为了要在那里拍一张属于自己的照片。\n努力！\n大阪万博纪念公园 在送学长去大阪的路上临时决定要去大阪的表弟家玩几天，表弟刚考完大阪大学修士，也算是说走就走的旅行了。不过包里就只有一把伞和一包湿巾，特意买了一套衣服换洗…所以冲动是有代价的。\n表弟考的很差，为了不让他伤心，那天尽力的陪他到处逛，看他不开心就鼓励他。毕竟没有什么事是能一遍成功的\n天王寺——あべのハルカス 天王寺的「あべのハルカス」是现在关西最高的ビル，入门券1500，里面甚至有餐厅可以烤肉。唯一缺点就是水太贵\n以后有机会会再上来一次，物超所值。\n从下午四点半待到了晚上七点，就为了看日落和夜景，不过确实是值得的。\n之前研究室日本人曾经跟我说过，大阪北部和南部差别很大，南边犯罪率高，治安很差\n北边高楼耸立，南边除了几个大型公园，几乎没有高层建筑(照片可能拍的位置不太对）\n非常经典的一幕，天王寺动物园车站北侧有一个看着很怪的会馆，应该是基督教会馆，但这外观看着像个邪教…\n车站南侧更诡异，走过来的时候路上很吓人，照片都没好意思拍，也可能那边的人看着吓人吧。不过在动物园周围看到了很多涂鸦的垃圾箱和流浪汉…在日本有涂鸦的话，治安应该是很差的…\n小动物 姬路城 最后一天去了姬路城，路上有一段靠海，风景很不错\n出发的晚，赶在入场截止一小时进了城，两个小时只把这两个城逛完了\n不愿清醒，宁愿一直沉迷放纵。不知归路，宁愿一世无悔追逐。\n","date":"2022-08-25T00:00:00Z","image":"http://www.jansonblog.com/p/202208/title_hu54cfe3eacd95e31739f6cf6e42583caf_177612_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jansonblog.com/p/202208/","title":"2022年8月生活日记"},{"content":"模板引擎 书中总结了以下模板：\n模板 Spring Boot starter依赖 JavaServer Pages(JSP) 无(由Tomcat或Jetty提供) FreeMarker spring-boot-starter-freemarker Groovy Templates spring-boot-starter-groovy-templates Mustache spring-boot-starter-mustache Thymeleaf spring-boot-starter-thymeleaf 其中，JSP不需要依赖的原因:\n是因为Servlet容器本身（默认是Tomcat）会实现JSP，因此不需要额外的依赖。 使用JSP问题：\nJava Servlet容器包括嵌入式的Tomcat和Jetty容器，通常会在“/WEB-INF”目录下寻找JSP。如果将应用构建成一个可执行的JAR文件，就无法满足这种需求；只有在将应用构建成WAR文件并部署到Servlet容器中时，才能选择JSP方案。 模板缓存 默认情况下，模板只有在第⼀次使用的时候解析⼀次，解析的结果会被后续的请求所使⽤。开发期缓存存在时，想要看到变更效果，必须重新启动应用，非常不方便 禁用模板缓存：将相关缓存属性设成false:在application.properties中添加： spring.thymeleaf.cache=false 模板 启用缓存的属性 FreeMarker spring.freemarker.cache Groovy Templates spring.groovy.template.cache Mustache spring.mustache.cache Thymeleaf spring.thymeleaf.cache Thymeleaf模板 Thymeleaf 模板只是 HTML 与一些额外的元素属性，指导模板在渲染请求数据。\n例如，如果有一个请求属性，它的键是 “message”，你希望它被Thymeleaf渲染成一个HTML\u0026lt;p\u0026gt;标签，你可以在你的Thymeleaf模板中写以下内容：\n\u0026lt;p th:text=\u0026quot;${message}\u0026quot;\u0026gt;placeholder message\u0026lt;/p\u0026gt;\nThymeleaf 提供了一个内置的field.hasErrors方法，该方法根据给定字段是否存在任何错误返回一个布尔值。\n例如要在一个信用卡号字段上显示验证错误：\n\u0026lt;label for=\u0026quot;ccNumber\u0026quot;\u0026gt;Credit Card #: \u0026lt;/label\u0026gt;·\n\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{ccNumber}\u0026quot;/\u0026gt;\n\u0026lt;span class=\u0026quot;validationError\u0026quot; th:if=\u0026quot;${#fields.hasErrors('ccNumber')}\u0026quot; th:errors=\u0026quot;*{ccNumber}\u0026quot;\u0026gt;CC Num Error\u0026lt;/span\u0026gt;\n如有遗漏或错误，欢迎补充纠正\n","date":"2022-08-15T00:00:00Z","image":"http://www.jansonblog.com/p/spring2/1_huc955137a63590f4561b0a715bdaca55f_11288_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jansonblog.com/p/spring2/","title":"Spring学习之路（二）"},{"content":"前言 学习路程是按照Spring实战（第五版）进行，本系列只针对笔者自己进行内容总结，用于加深学习以及日后回顾使用。如感兴趣，推荐阅读参考图书进行学习。\n书中有较多地方描述比较不清楚，实战时，存在很多问题。spring-in-action-5-samples对书中每一章项目进行了汇总，对照此仓库学习更容易理解。\nSpring项目结构 mvnw和mvnw.cmd：这是Maven包装器（wrapper）脚本，借助脚本，即使没有安装Maven也可以构建项目 pom.xml： Maven构建规范，用于引入依赖等 Application.java：SpringBoot主类 application.properties：初始为空，用来指定配置属性 static：初始为空，用于存放静态内容（图片，样式表，JavaScript等） templates：初始为空，用于存放渲染内容到浏览器的模板文件 ApplicationTests.java：简单的测试类，确保Spring应用上下文成功加载 @SpringBootApplication组合注解 @SpringBootApplication是一个组合注解，它组合了3个其他的注释：\n@SpringBootConfiguration：将该类声明为配置类。尽管这个类⽬前还没有太多的配置，但是后续我们可以按需添加基于Java的Spring框架配置。这个注解实际上是@Configuration注解的特殊形式。 @EnableAutoConfiguration：启⽤Spring Boot的⾃动配置。我们随后会介绍⾃动配置的更多功能。就现在来说，我们只需要知道这个注解会告诉Spring Boot⾃动配置它认为我们会⽤到的组件。 @ComponentScan：启⽤组件扫描。这样我们能够通过像@Component、 @Controller、@Service这样的注解声明其他类，Spring会⾃动发现它们并将它们注册为Spring应⽤上下⽂中的组件 Spring的一些重点项目： Spring MVC——Spring的Web框架：可以边写控制器处理Web请求；创建REST API，生成非HTML的输出 Spring Boot：starter依赖和自动配置；Actuator能洞察应用运行时的内部工作状况；灵活的环境属性规范；在核心框架的测试辅助功能之上提供了对测试的额外支持 Spring Data：将应用程序数据repository定义为java接口，定义驱动存储和检索数据的方法时使用一种命名约定即可；能够处理不同类型的数据库，包括关系型数据库（JPA）、文档数据库（Mongo）、图数据库（Neo4j）等 Spring Security：Spring的安全框架，解决了身份验证、授权和API安全性等安全性需求 Spring Integration：解决实时集成问题，数据在可用时马上就会得到处理 Spring Batch：批处理集成问题——数据收集一段时间，直到触发触发器，才进行批处理 Spring Cloud：使用Spring开发云原生应用程序的项目 如有遗漏或错误，欢迎补充纠正\n","date":"2022-08-13T00:00:00Z","image":"http://www.jansonblog.com/p/spring1/1_huc955137a63590f4561b0a715bdaca55f_11288_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jansonblog.com/p/spring1/","title":"Spring学习之路（一）"},{"content":"基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 git init // 初始化仓库，生成.git目录 git status // 查看仓库的状态，显示目前分支，以及有没有可疑提交的内容 git add 要添加的文件 // 向暂存区添加文件 git commit // 执行启动编辑器，可以记述更加详细的信息 git commit -m \u0026#34;本次的提交注释\u0026#34;// 添加对提交的概述； git commit --amend // 修改上一条提交信息 git log // 查看提交日志 git log --pretty=short // 显示第一行简述信息 git log 文件名或目录名 //显示指定文件的日志 git log -p // 查看提交带来的变动，显示文件前后差别 git log -p 文件名或目录名 //查看指定文件的变动 git reflog // 查看当前仓库执行过的操作的日志 git diff // 查看当前工作树与暂存区的差别 git diff HEAD // 查看与最新提交的差别，在git commit前执行这条命令是个好习惯 分支的操作 1 2 3 4 5 6 7 8 9 10 11 12 git branch // 显示分支一览表 git checkout -b 新分支名 // 创建并切换到新的分支； /以上命令与“git branch 新分支名”，再执行“git git checkout 新分支名”效果相同/ git checkout 分支名 // 切换到分支 git checkout - // 切换到上一个分支 git merge // 合并分支 git merge --no-ff A // 将分支A合并到当前分支，并启动编辑器录入合并提交的信息 git log --graph // 以图表形式查看分支 更改提交的操作 1 2 3 4 /使用git reflog 查看仓库日志，第一列为时间哈希值/ git reset // 回溯历史版本 git reset --hard 目标时间点的哈希值 // 恢复到时间点的状态， 推送至远程仓库 1 2 3 4 5 6 7 8 9 // 将远程仓库的名称设置为origin（标识符） git remote add origin git@github.com:用户名/git-tutorial.git git remote -v // 查看当前远程仓库 git push // 推送至远程仓库 git push -u origin master // 将当前分支内容推送给远程仓库origin的master分支； // -u参数在推送的同时，将origin仓库的master分支设置为本地仓库当前分支的upstream（上游）, // 运行git pull 命令，本地仓库的这个分支可以直接从origin的master分支获取内容 从远程仓库获取 1 2 3 4 git clone // 将github仓库clone到本地，注意不要与之前操作的仓库在同一目录下 git checkout -b A origin/A //以远程仓库分支A为来源，在本地新建分支A git pull // 获取最新的远程仓库分支 其他深入理解Git的资料 Pro Git (零基础的git学习资料) LearnGitBranching (学习git基本操作的网站) tryGit (只有英文版的网站) 如有遗漏或错误，欢迎补充纠正\n","date":"2022-08-09T00:00:00Z","image":"http://www.jansonblog.com/p/git/git_huc4816c34e5eac99387927d6062922be7_29780_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jansonblog.com/p/git/","title":"如何使用git"},{"content":"美景 研究室那些事儿 又吃啥了 生活 祝你今天愉快，你明天的愉快留着我明天再祝。\n","date":"2022-08-04T00:00:00Z","image":"http://www.jansonblog.com/p/202207/1_hu36311c6336afc9cbade18762d772f23a_126992_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jansonblog.com/p/202207/","title":"2022年7月散记"},{"content":"动态规划实现有两种方法：\n自下而上 (制表) 自上而下 (记忆化) 自下而上 自下而上是通过 迭代 实现的\n以斐波那契数列为例，F(0)=0, F(1)=1。通过F(0)和F(1)计算F(2)，然后使用计算结果计算F(3)…\n以此类推，一直计算F(n)\n1 2 3 4 5 6 7 // 伪代码如下: F = array of length (n + 1) F[0] = 0 F[1] = 1 for i from 2 to n: F[i] = F[i - 1] + F[i - 2] 自上而下 自上而下通过 递归 实现，并且通过 记忆化 提高效率(之后解释记忆化概念)\n如果我们想知道斐波那契数列F(n)，需要找到F(n-1)和F(n-2)…通过递归求出F(0)和F(1)\n缺点也很明显，在计算中存在大量的 重复计算 ，导致效率不高\n而解决方法也很简单，用空间换时间，也就是 记忆化 ：将函数调用的结果存储在哈希图或数组中，这样当再次进行相同的函数调用时，我们可以简单地返回记忆的结果，而不是重新计算结果。\n1 2 3 4 5 6 7 8 9 //伪代码如下: memo = hashmap Function F(integer i): if i is 0 or 1: return i if i doesn\u0026#39;t exist in memo: memo[i] = F(i - 1) + F(i - 2) return memo[i] 总结 所以，这两个算法哪个更好呢？\nDP(动态规划问题)可以用任意一种方法实现\n每个方法都有一个突出的优点:\n自下而上的运行速度更快 (递归效率低) 自上而下的实现更简单 (因为对于递归来说，我们不用在意子问题的逻辑顺序，而对于自下而上的方法来说，我们需要解决子问题的逻辑顺序) 比较简单而且经典的题目：《力扣 62.不同路径》\n学习资料如下:\nExplore - LeetCode\n如有遗漏或错误，欢迎补充纠正\n","date":"2022-05-27T00:00:00Z","image":"http://www.jansonblog.com/p/post1/PascalTriangleFibanacci_huc8c4888000c54215c84e1fbac83f0f75_66078_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jansonblog.com/p/post1/","title":"动态规划(Dynamic programming)问题解法"}]