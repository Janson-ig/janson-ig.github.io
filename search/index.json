[{"content":"KMP(Knuth-Morris-Pratt)算法： 字符串查找算法（简称为KMP算法）可在一个字符串S内查找一个词W的出现位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能的开始位置，此算法利用这一特性以避免重重复查找之前出现的字符。\n我对MKP的认识：其归属于DP问题，核心的思想在于对要查找的字符串进行处理——寻找最长的前缀。然后通过记忆化数组的方式，跳过不可能成功匹配的字符串位置，从下一个可能的位置进行搜索。利用要查找字符串的特性，利用其前缀和后缀的共同部分来简化搜索过程。\n算法原理： 简单的暴力搜索无非就是从每个可能的index开始，与要查找的字符串进行比较。 而KMP则会跳过已经匹配的部分，以维基百科的说明为例，简单概括过程：\n要查找的字符串W=\u0026ldquo;ABCDABD\u0026rdquo;，\n给定字符串S=\u0026ldquo;ABC ABCDAB ABCDABCDABDE\u0026rdquo;\n为例说明查找过程：\nS: ABC ABCDAB ABCDABCDABDE\nW: ABCDABD\nS[3]（=\u0026rsquo; \u0026rsquo;)与W[3]（=\u0026lsquo;D\u0026rsquo;）不匹配，所以跳过；从S[4]开始，与W[0]进行比较。 S:ABC ABCDAB ABCDABCDABDE\nW:ABCDABD\n从S[4]开始比较，当位于S[10]（=\u0026rsquo; \u0026rsquo;）时，与W对应的字符不匹配；但是此时可以注意到，\u0026quot;AB\u0026ldquo;在“ABCDAB\u0026ldquo;的头尾处均有出现——这意味着，尾部的“AB”可以作为下一次比较的起点。 所以下次从index = 8的位置： S:ABC ABCDAB ABCDABCDABDE\nW:ABCDABD\n即A开始进行匹配。 应用题目实战: LeetCode 28. Find the Index of the First Occurrence in a String\n题目实战日后补充说明\n同时推荐一个算法可视化工具：\nalgorithm-visualizer_KMP\n如有遗漏或错误，欢迎补充纠正\n","date":"2022-11-03T00:00:00Z","image":"http://www.jansonblog.com/p/kmp/1_hufc32a0c50659798267d43cbe27d64943_54921_120x120_fill_box_smart1_3.png","permalink":"http://www.jansonblog.com/p/kmp/","title":"KMP算法（字符串匹配算法）"},{"content":" Spring实战第五版中使用的WebSecurityConfigurerAdapter已被弃用 （还没学过就被弃用了\u0026hellip;） 第五章开始，使用最新的Spring实战第六版进行学习 Spring Security的密码编译器 密码编译器 加密方法 BCryptPasswordEncoder 应用 bcrypt 加强哈希加密 NoOpPasswordEncoder 不应用任何编码（对测试有用，不适合生产使用） Pbkdf2PasswordEncoder 应用 PBKDF2 加密 SCryptPasswordEncoder 应用 scrypt 哈希加密 StandardPasswordEncoder 应用 SHA-256 哈希加密（被认为不够安全，已经被弃用） 数据库中密码被加密；\n用户在login输入的密码使用相同的算法进行编码，在数据库使用PasswordEncoder的matches()方法进行比较。\nUserDetailsService实现： Spring Security提供了几个开箱即用的UserDetailsService实现：\n基于内存的用户存储 基于JDBC的用户存储 由LDAP支持的用户存储 1 2 3 4 5 6 7 8 9 /* *loadUserByUsername()方法接受用户名并使用它查找UserDetails对象。 *如果找不到给定用户名的用户，则抛出UsernameNotFoundException异常。 */ public interface UserDetailsService { UserDetails loadUserByUsername(String username) throws UsernameNotFoundException; } Securing web requests authorizeRequests()返回(ExpressionUrlAuthorizationConfigurer.ExpressionInterceptUrlRegistry)对象，允许指定URL路径和模式，以及路径对应的安全要求：\n书中项目的代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* *保证对于/design 和 /orders路径的请求只对认证的用户有效； *其他路径对于所有的用户有效； */ @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { return http .authorizeRequests() .antMatchers(\u0026#34;/design\u0026#34;, \u0026#34;/orders\u0026#34;).hasRole(\u0026#34;USER\u0026#34;) .antMatchers(\u0026#34;/\u0026#34;, \u0026#34;/**\u0026#34;).permitAll() .and() .build(); } Spring web requests的配置方法，以及如何保护路径如下：\n方法 作用 access(String) 如果给定的Spring Expression Language(SpEL)表达式求值为true，允许访问 anonymous() 允许匿名用户访问 authenticated() 允许通过验证的用户访问 denyAll() 无条件拒绝所有访问 fullyAuthenticated() 允许通过完全身份验证的用户访问（不推荐） hasAnyAuthority(String\u0026hellip;) 如果用户具有任何一个给定的权限，则允许访问（可代替hasAnyRole(String)方法） hasAnyRole(String…) 如果用户具有任何给定的角色，则允许访问 （自动加 ROLE_ 的前缀） hasAuthority(String) 如果用户具有指定的权限，则允许访问 hasRole(String) 如果用户具有指定的角色，则允许访问 hasIpAddress(String) 如果用户具有指定的IP地址，则允许访问 not() 否定任何其他认证方法的效果 permitAll() 无条件允许访问 rememberMe() 允许通过 remember-me 进行身份验证的用户访问 这其中值得注意的事，hasRole()方法可以被hasAuthority()代替：hasRole()方法自动补足 ROLE_ 的前缀。 设计上来看，一个是权限，一个是角色，角色是权限的集合体。 Spring Security对于SpEL表达式的扩展 Security expression SpEL的计算结果 authentication 用户的认证对象 denyAll 恒为false hasAnyAuthority(String\u0026hellip;authorities) 如果用户被授予所有权限中的某一个，则为true hasAnyRole(String\u0026hellip;roles) 如果用户有给定的roles中的某一个，则为true hasAnyAuthority(String authority) 如果用户被授予指定的权限，则为true hasPermission(Object target, Object permission) 如果用户能以给定的权限访问指定的目标对象，则为true hasRole(String role) 如果用户有给定的role，则为true hasIpAddress(String ipAddress) 如果请求来自指定ip，则为true isAnnoymous() 如果用户是匿名的，则为true isAuthenticated() 如果用户已认证，则为true isFullyAuthenticated() 如果用户经过完全身份验证(没有使用remember-me进行身份验证)，则为true isRememberMe() 如果用户使用remeber-me进行身份验证，则为true permitAll() 恒为true principal 用户的主要对象 remember-me（记住我）认证，就是常见的记住我：下次登录时，使用cookie导致自动登录发生。 1 2 3 4 5 6 7 8 9 10 11 12 13 /* *所以上面一节中的方法，可以用access()方法+security表达式的方式来实现； */ @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { return http .authorizeRequests() .antMatchers(\u0026#34;/design\u0026#34;, \u0026#34;/orders\u0026#34;).access(\u0026#34;hasRole(\u0026#39;USER\u0026#39;)\u0026#34;) .antMatchers(\u0026#34;/\u0026#34;, \u0026#34;/**\u0026#34;).access(\u0026#34;permitAll()\u0026#34;) .and() .build(); } 如有遗漏或错误，欢迎补充纠正\n","date":"2022-11-02T00:00:00Z","image":"http://www.jansonblog.com/p/spring3/1_huc955137a63590f4561b0a715bdaca55f_11288_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jansonblog.com/p/spring3/","title":"Spring学习之路（三）"},{"content":"近况 两个月没有更新博客，因为什么都没有做，把最近的一些事，漫无目的的记录下来。随缘配图，我把这篇作为最近内心的一片幽静之地，在混乱中整理思绪，毕竟这是我的博客，我不要管别人看起来如何。\n1.力扣 力扣依旧在每日刷题，现在基本上看到题可以判断出是什么题型，但是最近对于做题仿佛失去了一些思考。明知道只做出来是不对的，但是还是懒得去思考。或许是因为研究过于不顺，导致自己每天没有余力去探索。\n跟狗人和阿毛一起报名了力扣的一个什么比赛，六道题目，好像一个人四个小时。我和阿毛10分钟不到做完了1，2题，后面知道是dp但是没想出公式，加上那天后背的粉瘤爆炸，下午不得不赶在医院关门前去诊所，最后排名也就只能1000+的样子。\n好消息在比赛赚了1k积分，终于能换力扣全家桶了。但是，只能等回国再换，而我又什么时候可以回国呢。心中虽然有了回国的计划，但是最近研究的种种不顺，可能只能放弃寒假回国的计划，毕竟学会发表顺利毕业才是现阶段最重要的事。\n2.学习 LoRa网关真的很难搞，研究室没有人能帮，只能自己硬着头皮，顶着压力一点一点来。\n今天抱着试试的态度跟一个台湾的公司联络了一下，居然一个小时就收到了回信，虽然很简短，但是给了看起来有用的文档。看了一眼文档，前路漫漫，比想象中的要困难。进度一拖再拖，没有进展。\n3.掘金 最大的收获应该是认识了掘金的小伙伴。安安，小安，小鱼，鑫，master。一群五湖四海的人就因为一场游戏比赛聚到了一起。\n其中印象最深，聊的最多的是安安。安安是莱州的老乡。安安看着外表搞笑坚强，但是自述有些抑郁。我呢？我应该并不抑郁，不过在日本留学这几年，我内心也是孤独的，我似乎能体会到她和阿毛当时考研时的孤独。她的经历我周围有很多人跟她相似，但是她是一个非常外向的人，内心痛苦会释放。\n4.独白 安安是一个让我有时候会羡慕的人，因为她知道自己喜欢什么。而我，像王小波说的那样，原文我并不记得了，大概意思是：20岁是最迷茫的年龄，因为一个人要决定自己以后做什么。\n我又想做什么呢？自学了Java或许是出于一种喜爱，又或是承诺的履行？因为好像是舅舅跟我说可以学Java，但是我可能又是羡慕大一花旗那个保研清北的学长，因为在他口中Java是那么有趣。或许我确实对Java有自己的喜爱，才能在尝试过那么多语言后选择Java。\n总之，想起来舅妈说的话：“现在的年轻人迷茫是因为可以选的路太多了，她们那个年代，没有那么多路，大家不知不觉进了一条路就坚持走到了最后”。我也尽量不去想自己的选择，做出了选择就不要后悔。\n在我内心空虚的时候，都回去看王小波的文章，因为他的经历和三观符合我的内心。\n牢骚就发到这，因为まなびLAぼ要打卡下班了！\n无论遇到什么人，我都会一直看守着内心的那块净土，直到遇到你。\n","date":"2022-10-20T00:00:00Z","image":"http://www.jansonblog.com/p/202210/1_hud19e336ace294e14e66119b0592b486d_120198_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jansonblog.com/p/202210/","title":"2022年10月20日"},{"content":" 对于我们来说，八月的主旋律是悲伤，因为答辩在八月，八月是狂欢和离别的夏天\n毕业季——给学长送行 曲学长要去LINE福冈工作了，走之前前一夜只睡了2个两小时，看着那状态实在不放心，陪他坐车到了新大阪去换乘新干线（最后还是等错了站台，改了票…）\n我跟学长都很喜欢吃咖喱，但是学长基本不喝酒\nflag！ 跟学长约定，我拿到offer或者回国之前一定会去福冈找他。\n用了很久的头像，当时是随便找的，偶然发现这个照片居然是在福冈县的神社拍的，所以去福冈也是为了要在那里拍一张属于自己的照片。\n努力！\n大阪万博纪念公园 在送学长去大阪的路上临时决定要去大阪的表弟家玩几天，表弟刚考完大阪大学修士，也算是说走就走的旅行了。不过包里就只有一把伞和一包湿巾，特意买了一套衣服换洗…所以冲动是有代价的。\n表弟考的很差，为了不让他伤心，那天尽力的陪他到处逛，看他不开心就鼓励他。毕竟没有什么事是能一遍成功的\n天王寺——あべのハルカス 天王寺的「あべのハルカス」是现在关西最高的ビル，入门券1500，里面甚至有餐厅可以烤肉。唯一缺点就是水太贵\n以后有机会会再上来一次，物超所值。\n从下午四点半待到了晚上七点，就为了看日落和夜景，不过确实是值得的。\n之前研究室日本人曾经跟我说过，大阪北部和南部差别很大，南边犯罪率高，治安很差\n北边高楼耸立，南边除了几个大型公园，几乎没有高层建筑(照片可能拍的位置不太对）\n非常经典的一幕，天王寺动物园车站北侧有一个看着很怪的会馆，应该是基督教会馆，但这外观看着像个邪教…\n车站南侧更诡异，走过来的时候路上很吓人，照片都没好意思拍，也可能那边的人看着吓人吧。不过在动物园周围看到了很多涂鸦的垃圾箱和流浪汉…在日本有涂鸦的话，治安应该是很差的…\n小动物 姬路城 最后一天去了姬路城，路上有一段靠海，风景很不错\n出发的晚，赶在入场截止一小时进了城，两个小时只把这两个城逛完了\n不愿清醒，宁愿一直沉迷放纵。不知归路，宁愿一世无悔追逐。\n","date":"2022-08-25T00:00:00Z","image":"http://www.jansonblog.com/p/202208/title_hu54cfe3eacd95e31739f6cf6e42583caf_177612_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jansonblog.com/p/202208/","title":"2022年8月生活日记"},{"content":"模板引擎 书中总结了以下模板：\n模板 Spring Boot starter依赖 JavaServer Pages(JSP) 无(由Tomcat或Jetty提供) FreeMarker spring-boot-starter-freemarker Groovy Templates spring-boot-starter-groovy-templates Mustache spring-boot-starter-mustache Thymeleaf spring-boot-starter-thymeleaf 其中，JSP不需要依赖的原因:\n是因为Servlet容器本身（默认是Tomcat）会实现JSP，因此不需要额外的依赖。 使用JSP问题：\nJava Servlet容器包括嵌入式的Tomcat和Jetty容器，通常会在“/WEB-INF”目录下寻找JSP。如果将应用构建成一个可执行的JAR文件，就无法满足这种需求；只有在将应用构建成WAR文件并部署到Servlet容器中时，才能选择JSP方案。 模板缓存 默认情况下，模板只有在第⼀次使用的时候解析⼀次，解析的结果会被后续的请求所使⽤。开发期缓存存在时，想要看到变更效果，必须重新启动应用，非常不方便 禁用模板缓存：将相关缓存属性设成false:在application.properties中添加： spring.thymeleaf.cache=false 模板 启用缓存的属性 FreeMarker spring.freemarker.cache Groovy Templates spring.groovy.template.cache Mustache spring.mustache.cache Thymeleaf spring.thymeleaf.cache Thymeleaf模板 Thymeleaf 模板只是 HTML 与一些额外的元素属性，指导模板在渲染请求数据。\n例如，如果有一个请求属性，它的键是 “message”，你希望它被Thymeleaf渲染成一个HTML\u0026lt;p\u0026gt;标签，你可以在你的Thymeleaf模板中写以下内容：\n\u0026lt;p th:text=\u0026quot;${message}\u0026quot;\u0026gt;placeholder message\u0026lt;/p\u0026gt;\nThymeleaf 提供了一个内置的field.hasErrors方法，该方法根据给定字段是否存在任何错误返回一个布尔值。\n例如要在一个信用卡号字段上显示验证错误：\n\u0026lt;label for=\u0026quot;ccNumber\u0026quot;\u0026gt;Credit Card #: \u0026lt;/label\u0026gt;·\n\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{ccNumber}\u0026quot;/\u0026gt;\n\u0026lt;span class=\u0026quot;validationError\u0026quot; th:if=\u0026quot;${#fields.hasErrors('ccNumber')}\u0026quot; th:errors=\u0026quot;*{ccNumber}\u0026quot;\u0026gt;CC Num Error\u0026lt;/span\u0026gt;\n如有遗漏或错误，欢迎补充纠正\n","date":"2022-08-15T00:00:00Z","image":"http://www.jansonblog.com/p/spring2/1_huc955137a63590f4561b0a715bdaca55f_11288_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jansonblog.com/p/spring2/","title":"Spring学习之路（二）"},{"content":"前言 学习路程是按照Spring实战（第五版）进行，本系列只针对笔者自己进行内容总结，用于加深学习以及日后回顾使用。如感兴趣，推荐阅读参考图书进行学习。\n书中有较多地方描述比较不清楚，实战时，存在很多问题。spring-in-action-5-samples对书中每一章项目进行了汇总，对照此仓库学习更容易理解。\nSpring项目结构 mvnw和mvnw.cmd：这是Maven包装器（wrapper）脚本，借助脚本，即使没有安装Maven也可以构建项目 pom.xml： Maven构建规范，用于引入依赖等 Application.java：SpringBoot主类 application.properties：初始为空，用来指定配置属性 static：初始为空，用于存放静态内容（图片，样式表，JavaScript等） templates：初始为空，用于存放渲染内容到浏览器的模板文件 ApplicationTests.java：简单的测试类，确保Spring应用上下文成功加载 @SpringBootApplication组合注解 @SpringBootApplication是一个组合注解，它组合了3个其他的注释：\n@SpringBootConfiguration：将该类声明为配置类。尽管这个类⽬前还没有太多的配置，但是后续我们可以按需添加基于Java的Spring框架配置。这个注解实际上是@Configuration注解的特殊形式。 @EnableAutoConfiguration：启⽤Spring Boot的⾃动配置。我们随后会介绍⾃动配置的更多功能。就现在来说，我们只需要知道这个注解会告诉Spring Boot⾃动配置它认为我们会⽤到的组件。 @ComponentScan：启⽤组件扫描。这样我们能够通过像@Component、 @Controller、@Service这样的注解声明其他类，Spring会⾃动发现它们并将它们注册为Spring应⽤上下⽂中的组件 Spring的一些重点项目： Spring MVC——Spring的Web框架：可以边写控制器处理Web请求；创建REST API，生成非HTML的输出 Spring Boot：starter依赖和自动配置；Actuator能洞察应用运行时的内部工作状况；灵活的环境属性规范；在核心框架的测试辅助功能之上提供了对测试的额外支持 Spring Data：将应用程序数据repository定义为java接口，定义驱动存储和检索数据的方法时使用一种命名约定即可；能够处理不同类型的数据库，包括关系型数据库（JPA）、文档数据库（Mongo）、图数据库（Neo4j）等 Spring Security：Spring的安全框架，解决了身份验证、授权和API安全性等安全性需求 Spring Integration：解决实时集成问题，数据在可用时马上就会得到处理 Spring Batch：批处理集成问题——数据收集一段时间，直到触发触发器，才进行批处理 Spring Cloud：使用Spring开发云原生应用程序的项目 如有遗漏或错误，欢迎补充纠正\n","date":"2022-08-13T00:00:00Z","image":"http://www.jansonblog.com/p/spring1/1_huc955137a63590f4561b0a715bdaca55f_11288_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jansonblog.com/p/spring1/","title":"Spring学习之路（一）"},{"content":"基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 git init // 初始化仓库，生成.git目录 git status // 查看仓库的状态，显示目前分支，以及有没有可疑提交的内容 git add 要添加的文件 // 向暂存区添加文件 git commit // 执行启动编辑器，可以记述更加详细的信息 git commit -m \u0026#34;本次的提交注释\u0026#34;// 添加对提交的概述； git commit --amend // 修改上一条提交信息 git log // 查看提交日志 git log --pretty=short // 显示第一行简述信息 git log 文件名或目录名 //显示指定文件的日志 git log -p // 查看提交带来的变动，显示文件前后差别 git log -p 文件名或目录名 //查看指定文件的变动 git reflog // 查看当前仓库执行过的操作的日志 git diff // 查看当前工作树与暂存区的差别 git diff HEAD // 查看与最新提交的差别，在git commit前执行这条命令是个好习惯 分支的操作 1 2 3 4 5 6 7 8 9 10 11 12 git branch // 显示分支一览表 git checkout -b 新分支名 // 创建并切换到新的分支； /以上命令与“git branch 新分支名”，再执行“git git checkout 新分支名”效果相同/ git checkout 分支名 // 切换到分支 git checkout - // 切换到上一个分支 git merge // 合并分支 git merge --no-ff A // 将分支A合并到当前分支，并启动编辑器录入合并提交的信息 git log --graph // 以图表形式查看分支 更改提交的操作 1 2 3 4 /使用git reflog 查看仓库日志，第一列为时间哈希值/ git reset // 回溯历史版本 git reset --hard 目标时间点的哈希值 // 恢复到时间点的状态， 推送至远程仓库 1 2 3 4 5 6 7 8 9 // 将远程仓库的名称设置为origin（标识符） git remote add origin git@github.com:用户名/git-tutorial.git git remote -v // 查看当前远程仓库 git push // 推送至远程仓库 git push -u origin master // 将当前分支内容推送给远程仓库origin的master分支； // -u参数在推送的同时，将origin仓库的master分支设置为本地仓库当前分支的upstream（上游）, // 运行git pull 命令，本地仓库的这个分支可以直接从origin的master分支获取内容 从远程仓库获取 1 2 3 4 git clone // 将github仓库clone到本地，注意不要与之前操作的仓库在同一目录下 git checkout -b A origin/A //以远程仓库分支A为来源，在本地新建分支A git pull // 获取最新的远程仓库分支 其他深入理解Git的资料 Pro Git (零基础的git学习资料) LearnGitBranching (学习git基本操作的网站) tryGit (只有英文版的网站) 如有遗漏或错误，欢迎补充纠正\n","date":"2022-08-09T00:00:00Z","image":"http://www.jansonblog.com/p/git/git_huc4816c34e5eac99387927d6062922be7_29780_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jansonblog.com/p/git/","title":"如何使用git"},{"content":"美景 研究室那些事儿 又吃啥了 生活 祝你今天愉快，你明天的愉快留着我明天再祝。\n","date":"2022-08-04T00:00:00Z","image":"http://www.jansonblog.com/p/202207/1_hu36311c6336afc9cbade18762d772f23a_126992_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jansonblog.com/p/202207/","title":"2022年7月散记"},{"content":"动态规划实现有两种方法：\n自下而上 (制表) 自上而下 (记忆化) 自下而上 自下而上是通过 迭代 实现的\n以斐波那契数列为例，F(0)=0, F(1)=1。通过F(0)和F(1)计算F(2)，然后使用计算结果计算F(3)…\n以此类推，一直计算F(n)\n1 2 3 4 5 6 7 // 伪代码如下: F = array of length (n + 1) F[0] = 0 F[1] = 1 for i from 2 to n: F[i] = F[i - 1] + F[i - 2] 自上而下 自上而下通过 递归 实现，并且通过 记忆化 提高效率(之后解释记忆化概念)\n如果我们想知道斐波那契数列F(n)，需要找到F(n-1)和F(n-2)…通过递归求出F(0)和F(1)\n缺点也很明显，在计算中存在大量的 重复计算 ，导致效率不高\n而解决方法也很简单，用空间换时间，也就是 记忆化 ：将函数调用的结果存储在哈希图或数组中，这样当再次进行相同的函数调用时，我们可以简单地返回记忆的结果，而不是重新计算结果。\n1 2 3 4 5 6 7 8 9 //伪代码如下: memo = hashmap Function F(integer i): if i is 0 or 1: return i if i doesn\u0026#39;t exist in memo: memo[i] = F(i - 1) + F(i - 2) return memo[i] 总结 所以，这两个算法哪个更好呢？\nDP(动态规划问题)可以用任意一种方法实现\n每个方法都有一个突出的优点:\n自下而上的运行速度更快 (递归效率低) 自上而下的实现更简单 (因为对于递归来说，我们不用在意子问题的逻辑顺序，而对于自下而上的方法来说，我们需要解决子问题的逻辑顺序) 比较简单而且经典的题目：《力扣 62.不同路径》\n学习资料如下:\nExplore - LeetCode\n如有遗漏或错误，欢迎补充纠正\n","date":"2022-05-27T00:00:00Z","image":"http://www.jansonblog.com/p/post1/PascalTriangleFibanacci_huc8c4888000c54215c84e1fbac83f0f75_66078_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jansonblog.com/p/post1/","title":"动态规划(Dynamic programming)问题解法"}]