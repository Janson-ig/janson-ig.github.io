[{"content":"模板引擎 书中总结了以下模板：\n模板 Spring Boot starter依赖 JavaServer Pages(JSP) 无(由Tomcat或Jetty提供) FreeMarker spring-boot-starter-freemarker Groovy Templates spring-boot-starter-groovy-templates Mustache spring-boot-starter-mustache Thymeleaf spring-boot-starter-thymeleaf 其中，JSP不需要依赖的原因:\n是因为Servlet容器本身（默认是Tomcat）会实现JSP，因此不需要额外的依赖。 使用JSP问题：\nJava Servlet容器包括嵌入式的Tomcat和Jetty容器，通常会在“/WEB-INF”目录下寻找JSP。如果将应用构建成一个可执行的JAR文件，就无法满足这种需求；只有在将应用构建成WAR文件并部署到Servlet容器中时，才能选择JSP方案。 模板缓存 默认情况下，模板只有在第⼀次使用的时候解析⼀次，解析的结果会被后续的请求所使⽤。开发期缓存存在时，想要看到变更效果，必须重新启动应用，非常不方便 禁用模板缓存：将相关缓存属性设成false:在application.properties中添加： spring.thymeleaf.cache=false 模板 启用缓存的属性 FreeMarker spring.freemarker.cache Groovy Templates spring.groovy.template.cache Mustache spring.mustache.cache Thymeleaf spring.thymeleaf.cache Thymeleaf模板 Thymeleaf 模板只是 HTML 与一些额外的元素属性，指导模板在渲染请求数据。\n例如，如果有一个请求属性，它的键是 “message”，你希望它被Thymeleaf渲染成一个HTML\u0026lt;p\u0026gt;标签，你可以在你的Thymeleaf模板中写以下内容：\n\u0026lt;p th:text=\u0026quot;${message}\u0026quot;\u0026gt;placeholder message\u0026lt;/p\u0026gt;\nThymeleaf 提供了一个内置的field.hasErrors方法，该方法根据给定字段是否存在任何错误返回一个布尔值。\n例如要在一个信用卡号字段上显示验证错误：\n\u0026lt;label for=\u0026quot;ccNumber\u0026quot;\u0026gt;Credit Card #: \u0026lt;/label\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{ccNumber}\u0026quot;/\u0026gt; \u0026lt;span class=\u0026quot;validationError\u0026quot; th:if=\u0026quot;${#fields.hasErrors('ccNumber')}\u0026quot; th:errors=\u0026quot;*{ccNumber}\u0026quot;\u0026gt;CC Num Error\u0026lt;/span\u0026gt;\n如有遗漏或错误，欢迎补充纠正\n","date":"2022-08-15T00:00:00Z","image":"http://www.jansonblog.com/p/spring/1_huc955137a63590f4561b0a715bdaca55f_11288_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jansonblog.com/p/spring/","title":"Spring学习之路（二）"},{"content":"前言 学习路程是按照Spring实战（第五版）进行，本系列只针对笔者自己进行内容总结，用于加深学习以及日后回顾使用。如感兴趣，推荐阅读参考图书进行学习。\n书中有较多地方描述比较不清楚，实战时，存在很多问题。spring-in-action-5-samples对书中每一章项目进行了汇总，对照此仓库学习更容易理解。\nSpring项目结构 mvnw和mvnw.cmd：这是Maven包装器（wrapper）脚本，借助脚本，即使没有安装Maven也可以构建项目 pom.xml： Maven构建规范，用于引入依赖等 Application.java：SpringBoot主类 application.properties：初始为空，用来指定配置属性 static：初始为空，用于存放静态内容（图片，样式表，JavaScript等） templates：初始为空，用于存放渲染内容到浏览器的模板文件 ApplicationTests.java：简单的测试类，确保Spring应用上下文成功加载 @SpringBootApplication组合注解 @SpringBootApplication是一个组合注解，它组合了3个其他的注释：\n@SpringBootConfiguration：将该类声明为配置类。尽管这个类⽬前还没有太多的配置，但是后续我们可以按需添加基于Java的Spring框架配置。这个注解实际上是@Configuration注解的特殊形式。 @EnableAutoConfiguration：启⽤Spring Boot的⾃动配置。我们随后会介绍⾃动配置的更多功能。就现在来说，我们只需要知道这个注解会告诉Spring Boot⾃动配置它认为我们会⽤到的组件。 @ComponentScan：启⽤组件扫描。这样我们能够通过像@Component、 @Controller、@Service这样的注解声明其他类，Spring会⾃动发现它们并将它们注册为Spring应⽤上下⽂中的组件 Spring的一些重点项目： Spring MVC——Spring的Web框架：可以边写控制器处理Web请求；创建REST API，生成非HTML的输出 Spring Boot：starter依赖和自动配置；Actuator能洞察应用运行时的内部工作状况；灵活的环境属性规范；在核心框架的测试辅助功能之上提供了对测试的额外支持 Spring Data：将应用程序数据repository定义为java接口，定义驱动存储和检索数据的方法时使用一种命名约定即可；能够处理不同类型的数据库，包括关系型数据库（JPA）、文档数据库（Mongo）、图数据库（Neo4j）等 Spring Security：Spring的安全框架，解决了身份验证、授权和API安全性等安全性需求 Spring Integration：解决实时集成问题，数据在可用时马上就会得到处理 Spring Batch：批处理集成问题——数据收集一段时间，直到触发触发器，才进行批处理 Spring Cloud：使用Spring开发云原生应用程序的项目 如有遗漏或错误，欢迎补充纠正\n","date":"2022-08-13T00:00:00Z","image":"http://www.jansonblog.com/p/spring/1_huc955137a63590f4561b0a715bdaca55f_11288_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jansonblog.com/p/spring/","title":"Spring学习之路（一）"},{"content":"基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 git init // 初始化仓库，生成.git目录 git status // 查看仓库的状态，显示目前分支，以及有没有可疑提交的内容 git add 要添加的文件 // 向暂存区添加文件 git commit // 执行启动编辑器，可以记述更加详细的信息 git commit -m \u0026#34;本次的提交注释\u0026#34;// 添加对提交的概述； git commit --amend // 修改上一条提交信息 git log // 查看提交日志 git log --pretty=short // 显示第一行简述信息 git log 文件名或目录名 //显示指定文件的日志 git log -p // 查看提交带来的变动，显示文件前后差别 git log -p 文件名或目录名 //查看指定文件的变动 git reflog // 查看当前仓库执行过的操作的日志 git diff // 查看当前工作树与暂存区的差别 git diff HEAD // 查看与最新提交的差别，在git commit前执行这条命令是个好习惯 分支的操作 1 2 3 4 5 6 7 8 9 10 11 12 git branch // 显示分支一览表 git checkout -b 新分支名 // 创建并切换到新的分支； /以上命令与“git branch 新分支名”，再执行“git git checkout 新分支名”效果相同/ git checkout 分支名 // 切换到分支 git checkout - // 切换到上一个分支 git merge // 合并分支 git merge --no-ff A // 将分支A合并到当前分支，并启动编辑器录入合并提交的信息 git log --graph // 以图表形式查看分支 更改提交的操作 1 2 3 4 /使用git reflog 查看仓库日志，第一列为时间哈希值/ git reset // 回溯历史版本 git reset --hard 目标时间点的哈希值 // 恢复到时间点的状态， 推送至远程仓库 1 2 3 4 5 6 7 8 9 // 将远程仓库的名称设置为origin（标识符） git remote add origin git@github.com:用户名/git-tutorial.git git remote -v // 查看当前远程仓库 git push // 推送至远程仓库 git push -u origin master // 将当前分支内容推送给远程仓库origin的master分支； // -u参数在推送的同时，将origin仓库的master分支设置为本地仓库当前分支的upstream（上游）, // 运行git pull 命令，本地仓库的这个分支可以直接从origin的master分支获取内容 从远程仓库获取 1 2 3 4 git clone // 将github仓库clone到本地，注意不要与之前操作的仓库在同一目录下 git checkout -b A origin/A //以远程仓库分支A为来源，在本地新建分支A git pull // 获取最新的远程仓库分支 其他深入理解Git的资料 Pro Git (零基础的git学习资料) LearnGitBranching (学习git基本操作的网站) tryGit (只有英文版的网站) 如有遗漏或错误，欢迎补充纠正\n","date":"2022-08-09T00:00:00Z","image":"http://www.jansonblog.com/p/git/git_huc4816c34e5eac99387927d6062922be7_29780_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jansonblog.com/p/git/","title":"如何使用git"},{"content":"美景 研究室那些事儿 又吃啥了 生活 祝你今天愉快，你明天的愉快留着我明天再祝。\n","date":"2022-08-04T00:00:00Z","image":"http://www.jansonblog.com/p/202207/1_hu36311c6336afc9cbade18762d772f23a_126992_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jansonblog.com/p/202207/","title":"2022年7月散记"},{"content":"动态规划实现有两种方法：\n自下而上 (制表) 自上而下 (记忆化) 自下而上 自下而上是通过 迭代 实现的\n以斐波那契数列为例，F(0)=0, F(1)=1。通过F(0)和F(1)计算F(2)，然后使用计算结果计算F(3)…\n以此类推，一直计算F(n)\n1 2 3 4 5 6 7 // 伪代码如下: F = array of length (n + 1) F[0] = 0 F[1] = 1 for i from 2 to n: F[i] = F[i - 1] + F[i - 2] 自上而下 自上而下通过 递归 实现，并且通过 记忆化 提高效率(之后解释记忆化概念)\n如果我们想知道斐波那契数列F(n)，需要找到F(n-1)和F(n-2)…通过递归求出F(0)和F(1)\n缺点也很明显，在计算中存在大量的 重复计算 ，导致效率不高\n而解决方法也很简单，用空间换时间，也就是 记忆化 ：将函数调用的结果存储在哈希图或数组中，这样当再次进行相同的函数调用时，我们可以简单地返回记忆的结果，而不是重新计算结果。\n1 2 3 4 5 6 7 8 9 //伪代码如下: memo = hashmap Function F(integer i): if i is 0 or 1: return i if i doesn\u0026#39;t exist in memo: memo[i] = F(i - 1) + F(i - 2) return memo[i] 总结 所以，这两个算法哪个更好呢？\nDP(动态规划问题)可以用任意一种方法实现\n每个方法都有一个突出的优点:\n自下而上的运行速度更快 (递归效率低) 自上而下的实现更简单 (因为对于递归来说，我们不用在意子问题的逻辑顺序，而对于自下而上的方法来说，我们需要解决子问题的逻辑顺序) 比较简单而且经典的题目：《力扣 62.不同路径》\n学习资料如下:\nExplore - LeetCode\n如有遗漏或错误，欢迎补充纠正\n","date":"2022-05-27T00:00:00Z","image":"http://www.jansonblog.com/p/post1/PascalTriangleFibanacci_huc8c4888000c54215c84e1fbac83f0f75_66078_120x120_fill_q75_box_smart1.jpg","permalink":"http://www.jansonblog.com/p/post1/","title":"动态规划(Dynamic programming)问题解法"}]