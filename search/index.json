[{"content":"牢骚 2024年10月21日一个沿海的小县城通了高铁。 等到高铁通到了北京，我想跟她一起去 北京，北京，北京。 北京是旧时代人心中的圣地，是新时代人痛并快乐的舞台。\n","date":"2024-10-22T00:00:00Z","image":"http://www.jansonblog.com/p/2024-10/13_hu4198397638381850070.jpg","permalink":"http://www.jansonblog.com/p/2024-10/","title":"2024年10月22日"},{"content":"平等院 平等院周边1 平等院周边2 宇治川1 宇治川2 ","date":"2024-05-26T00:00:00Z","image":"http://www.jansonblog.com/p/uji/DSC_0480_hu6821631617994170485.jpg","permalink":"http://www.jansonblog.com/p/uji/","title":"宇治"},{"content":"六甲山 海边 神户塔 KOBE 中日友好建筑（抽象 黄昏 ","date":"2024-05-18T00:00:00Z","image":"http://www.jansonblog.com/p/kobe/DSC_0469_hu10018385474828960985.jpg","permalink":"http://www.jansonblog.com/p/kobe/","title":"神户"},{"content":"4.30-5.6 公园 毛毛 国潮 大疆 世界之窗（抽象 香港 ","date":"2024-04-30T00:00:00Z","image":"http://www.jansonblog.com/p/goldenweek/DSC_0028_hu5054292654929153908.jpg","permalink":"http://www.jansonblog.com/p/goldenweek/","title":"2024年黄金周"},{"content":"学业 半年的折磨，每日每夜跑实验采集数据。自己选的课题，哭着也要做完。\n论文老师和博士看完很满意。赶在学会投稿截止日期前，投上了(投完发现有个图注释配反了)。 工作 3月和4月两个月，拿到了3家offer。一家国内银行，一家在日本的中国人公司，一家京都的半导体公司。\n最后选择了那家半导体公司。\n反省 自制力比以前好了，但是没半年前阳光了。\n","date":"2023-10-18T00:00:00Z","image":"http://www.jansonblog.com/p/2023-10/1_hu14295063674305222361.jpg","permalink":"http://www.jansonblog.com/p/2023-10/","title":"2023年10月18日"},{"content":"简介 \u0026amp; 原理 格雷码（Gray code）是由贝尔实验室的Frank Gray在1940年提出，用于在PCM（脉冲编码调变）方法传送讯号时防止出错。\n格雷码是一个数列集合，相邻两数间只有一个位元改变，为无权数码，且格雷码的顺序不是唯一的。\n原理：\n传统的二进位系统，例如数字3的表示法为011，要切换为邻近的数字4，也就是100时，装置中的三个位元都得要转换，因此于未完全转换的过程时装置会经历短暂的，010,001,101,110,111等其中数种状态，也就是代表着2、1、5、6、7，因此此种数字编码方法于邻近数字转换时有比较大的误差可能范围。 格雷码的发明即是用来将误差之可能性缩减至最小，编码的方式定义为每个邻近数字都只相差一个位元，因此也称为最小差异码，可以使装置做数字步进时只更动最少的位元数以提高稳定性。\n代码实现 用G代表格雷码：\n例如3位数的格雷码序列为：000,001,011,010,110,111,101,100。111可以用G(4) = 6来表示。\n公式：G(n) = n ^ (n \u0026gt;\u0026gt; 1)\n1 2 3 int g (int n) { return n ^ (n \u0026gt;\u0026gt; 1); } 例题 [medium]1238. Circular Permutation in Binary Representation\n如有遗漏或错误，欢迎补充纠正\n","date":"2023-02-23T00:00:00Z","image":"http://www.jansonblog.com/p/graycode/1_hu3778573576460902031.jpg","permalink":"http://www.jansonblog.com/p/graycode/","title":"格雷码（Gray code）"},{"content":"欧几里得算法（辗转相除法） 递归实现 1 2 3 4 5 private int gcd(int x, int y){ if(y == 0) return x; return gcd(y, x % y); } 迭代实现 1 2 3 4 5 6 7 8 public int gcd(int x, int y) { while(y != 0) { int tmp = x; x = y; y = tmp % y; } return a; } 例题 [easy]1071. Greatest Common Divisor of Strings\n如有遗漏或错误，欢迎补充纠正\n","date":"2023-02-01T00:00:00Z","image":"http://www.jansonblog.com/p/gcd/1_hu15976096432739536652.jpg","permalink":"http://www.jansonblog.com/p/gcd/","title":"GCD算法（最大公因数算法）"},{"content":" 创建自己的配置属性 这章讲的有点啰嗦，主要就讲了一个注解：\n@ConfigurationProperties：\nSpring Boot提供的支持配置属性的注入注释。放到Spring bean上后，它会为该bean中那些能够根据Spring环境注入值的属性赋值。\n@ConfigurationProperties实际上通常会放到⼀种特定类型的bean中，这种bean的⽬的就是持有配置数据。这样的话，特定的配置细节就能从控制器和其他应⽤程序类中抽离出来，多个bean也能更容易地共享⼀些通⽤的配置。\n注：Pageable是Spring Data根据页号和每页数量选取结果的子集的一种方法。\nSpring profile搭建特定环境的配置 profile是⼀种条件化的配置，在运⾏时，根据哪些profile处于激活状态，可以使⽤或忽略不同的bean、配置类和配置属性\n定义特定profile 定义特定profile相关的属性的⼀种⽅式就是创建另外⼀个YAML或属性⽂件，其中只包含⽤于⽣产环境的属性。\n⽂件的名称要遵守如下的约定：application-{profile名}.yml或 application-{profile名}.properties。\n方法1\n新建名为application-prod.yml的文件，包含以下属性： 1 2 3 4 5 6 7 8 spring: datasource: url: jdbc:mysql://localhost/tacocloud username: tacouser password: tacopassword logging: level: tacos: WARN 方法2\n将特定的profile和非特定profile的属性都放到application.yml中，二者之间使用三个中线【\u0026mdash;】进行分隔，并且使用spring.profiles属性来命名profile。application.yml如下所示： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 logging: level: tacos: DEBUG --- spring: profiles: prod datasource: url: jdbc:mysql://localhost/tacocloud username: tacouser password: tacopassword logging: level: tacos: WARN 该文件通过中划线(\u0026mdash;)分成两部分。第二部分制定了spring.profiles值，代表后面的属性适用于prod profile。\n第一部分没有指定spring.profiles，所以是所有profiles通用的，如果当前激活的profiles没有设置这些属性，它们会作为默认值。\n解释：\n在上述例子，不管程序运行的时候哪个profile处于激活状态，根据默认profile，包的日志级别都会设为DEBUG。\n但是如果名为prod的profile激活，logging.level.tacos属性会被重写为WARN。同理，如果prod profile处于激活状态，数据源相关属性会被设置为使用外部的MySQL数据库。 激活profile（三个方法） 需要将profile名称的列表赋值给spring.profiles.active属性。例如，在application.yml文件中： 1 2 3 4 spring: profiles: active: - prod 如果这么激活，这个profile就会成为默认profile。体验不到使用profile将生产环境和开发环境属性分开的好处。 2. % export SPRING_PROFILES_ACTIVE=prod 3. 以JAR文件形式运行，可以以命令行参数的形式设置要激活的profile：\n% java -jar taco-cloud.jar --spring.profiles.active=prod\n设置多个profile(两个方法) YAML中： 1 2 3 4 5 6 spring: profiles: active: - prod - audit - ha % export SPRING_PROFILES_ACTIVE=prod,audit,ha 如果使用Cloud Foundry Spring应用部署在Cloud Foundry，会自动激活名为cloud的profile，只需将生产环境相关的配置放到cloud profile下。\n使用profile条件化地创建bean @Profile注解可以将某些bean设置为仅适用于给定的profile，例如：\n1 2 3 4 5 6 @Bean @Profile(\u0026#34;dev\u0026#34;) public CommandLineRunner dataLoader(IngredientRepository repo, UserRepository userRepo, PasswordEncoder encoder) { ... } 用法：\n@Profile(\u0026quot;dev\u0026quot;):在dev profile激活时创建该bean @Profile({\u0026quot;dev\u0026quot;, \u0026quot;qa\u0026quot;})：dev或qa profile激活的时候创建该bean @Profile(\u0026quot;!prod\u0026quot;)：prod profile不激活就创建该bean 与@Configuration注解一起使用：\n将 CommandLineRunner抽取到一个名为DevelopmentConfig的配置类中： 1 2 3 4 5 6 7 8 9 @Profile({\u0026#34;!prod\u0026#34;, \u0026#34;!qa\u0026#34;}) @Configuration public class DevelopmentConfig { @Bean public CommandLineRunner dataLoader(IngredientRepository repo, UserRepository userRepo, PasswordEncoder encoder) { ... } } 只有prod和qa均没有激活的情况下才创建该bean。\n本章完。\n如有遗漏或错误，欢迎补充纠正\n","date":"2022-12-16T00:00:00Z","image":"http://www.jansonblog.com/p/spring6/1_hu9741472974145540847.jpg","permalink":"http://www.jansonblog.com/p/spring6/","title":"Spring学习之路（六）"},{"content":" 我一直是ssh远程操作的，之前ctrl+鼠标左键一直好用，可以跳转到对应函数的位置。\n但是最近突然不好用了，解决方法很简单：\nvscode里重装C/C++拓展 先是尝试了在本地运行一个简单的.c文件，结果提示找不到类型为“cppdbg”的调试适配器。\n然后卸载重装远程C/C++拓展，问题解决！\n","date":"2022-12-15T00:00:00Z","image":"http://www.jansonblog.com/p/tips-1/1_hu6347952054558429592.png","permalink":"http://www.jansonblog.com/p/tips-1/","title":"vscode中ctrl+左键不跳转"},{"content":" 第六章内容第五版与第六版几乎相同。本章介绍了自动配置bean；创建自己的配置属性；使用profile进行配置。\n自动配置： 细粒度的自动配置 两种不同但相关的配置\nBean wiring（装配bean）：声明在Spring应⽤上下⽂中创建哪些应⽤组件以及它们应该如何相互注入。 Property injection（依赖注入）声明在Spring应⽤上下⽂中创建哪些应⽤组件以及它们应该如何相互注入。 在Spring的XML和Java配置中，这两种类型的配置通常在同一个地方显式声明。\n在Java配置中，带@bean注解的方法很可能既实例化一个bean，又给它的属性赋值。举例来说，@Bean方法为H2数据库声明一个数据源：\n1 2 3 4 5 6 7 8 @Bean public DataSource dataSource() { return new EmbeddedDatabaseBuilder() .setType(H2) .addScript(\u0026#34;taco_schema.sql\u0026#34;) .addScripts(\u0026#34;user_data.sql\u0026#34;, \u0026#34;ingredient_data.sql\u0026#34;) .build(); } addScript() 和 addScripts()方法通过设置String属性来确定数据源——这是不使用Spring Boot的配置方法。\n如果在运行时类路径中能够找到H2依赖，那么Spring Boot会自动在Spring应用上下文中创建对应的DataSource bean。这个bean会运行名为schema.sql和data.sql的脚本。\nSpring的环境抽象 Spring的环境抽象\nSpring环境会拉取多个属性源：\nJVM系统属性 操作系统环境变量 命令行参数 应用属性配置文件 将这些属性聚合到一个源中，通过这个源可以注入到spring的bean中。如下图所示： Spring boot自动配置的bean都可以通过spring环境提取的属性进行配置.\n例如，希望底层Servlet容器使用另一个端口监听，有以下四个不同的方法：\n“src/main/resources/application.properties”将server.port设置成一个不同的端口：server.port = 9090 “src/main/resources/application.yml”中: server : port : 9090 命令行参数启动时指定端口：$ java -jar tacocloud-0.0.5-SNAPSHOT.jar \u0026ndash;server.port=9090 操作系统环境变量进行一次配置：$ export SERVER_PORT=9090（Spring能自动挑选环境变量名，将其解析） 配置数据源 显示配置自己的datasource:\n在application.yml配置：\n1 2 3 4 5 spring: datasource: url: jdbc:mysql://localhost/tacocloud username: tacodb password: tacopassword 尽管我们需要将对应的JDBC驱动添加到构建⽂件中，但是我们不需要指定JDBC驱动类。Spring Boot会根据数据库URL的结构推算出来。\n设置JDBC驱动类 然⽽，我们依然可以通过spring.datasource.driver-class-name属性来进⾏设置JDBC驱动类：\n1 2 3 4 5 6 spring: datasource: url: jdbc:mysql://localhost/tacocloud username: tacodb password: tacopassword driver-class-name: com.mysql.jdbc.Driver Spring boot自动化配置DataSource bean的时候，会使用该连接。如果类路径存在HikariCP的连接池，会使用该连接池。否则在类路径查找并使用以下连接池：\nTomcat JDBC Connection Pool Apache Commons DBCP 2 注：旧版默认连接池是Tomcat的JDBC连接池，新版默认连接池已经变成HikariCP，因为它够快，代码量少，稳定。\n配置嵌入式服务器 如果在配置servlet容器端口时，将端口设为0，即：\n1 2 server: Port : 0 会发生什么？\n虽然显式设为0，但是服务器不会在端口0上启动。而是任选一个可用的端口。这在运行自动化集成测试的时候，非常有用：因为可以保证并发运行的测试不会与硬编码的端口号冲突。\n配置使其处理HTTPS请求 底层服务器配置不仅局限于一个端口，底层容器最常见的一项设置是让它处理HTTPS请求。\n为了实现，需要使用JDK的keytool命令行工具生成keystore：\n$ keytool -keystore mykeys.jks -genkey -alias tomcat -keyalg RSA\n接下来，为了在嵌入式服务器中启用HTTPS，需要设置属性：\n可以在命令行中设置，但是不方便 可以通过application.properties或application.yml文件来声明配置： 1 2 3 4 5 6 server: port: 8443 ssl: key-store: file:/ / /path/to/mykeys.jks key-store-password: letmein key-password: letmein 解释：\n端口设为8443（开发阶段HTTPS服务器的常用选择） server.ssl.key-store设置为所创建的keystore路径 server.ssl.key-store-password和server.ssl.key-password属性设置为创建keystore所设置的密码 属性准备就绪后，应用会监听8443端口的HTTPS请求。\n配置日志 默认情况下，Spring Boot通过Logback配置日志，日志以INFO级别写入到控制台\n为了完全控制日志的配置，可以在类路径的根目录下src/main/resources创建logback.xml文件。\n简单样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;configuration\u0026gt; \u0026lt;appender name=\u0026#34;STDOUT\u0026#34; class=\u0026#34;ch.qos.logback.core.ConsoleAppender\u0026#34;\u0026gt; \u0026lt;encoder\u0026gt; \u0026lt;pattern\u0026gt; %d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n \u0026lt;/pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;logger name=\u0026#34;root\u0026#34; level=\u0026#34;INFO\u0026#34;/\u0026gt; \u0026lt;root level=\u0026#34;INFO\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;STDOUT\u0026#34; /\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/configuration\u0026gt; 这个Logback和没有logback.xml文件时的默认行为是几乎完全相同的。但是编辑logback.xml文件，可以完全控制应用的日志文件。\n日志配置中最常见变更是修改日志级别和指定日志写入到某个文件，Spring Boot的配置属性功能如何实现？\n设置日志级别：\n在application.yml中添加条目，例如： 1 2 3 4 logging: level: root: WARN org.springframework.security: DEBUG 以上配置将root logging设置为WARN级别，spring security的日志级别设为DEBUG。\n将日志条目写入指定文件： 如要将日志条目写入到\u0026quot;/var/logs/\u0026ldquo;中的TacoCloud文件中logging.path和logging.file文件可以如下配置： 1 2 3 4 5 6 7 8 9 logging: file: path: /var/logs/ file: TacoCloud.log level: root: WARN org: springframework: security: DEBUG 如果应用具有指定目录的写入权限，日志条目会被写入到指定目录。\n默认情况下，日志文件达到10MB就会轮换。\n使用特定的属性值 设置属性不局限于将值设置为硬编码的String或数值，可以从其他的配置属性派生值：\n假设我们想要设置⼀个名为greeting.welcome的属性，它的值来源于名为spring.application.name的另⼀个属性： 在设置greeting.welcome的时候，可以使用${}占位符标记：\n1 2 greeting: welcome: ${spring.application.name} 甚至可以将${}占位符嵌入到其他文本中：\n1 2 greeting: welcome: You are using ${spring.application.name}. 在配置Spring⾃⼰的组件时，使⽤配置属性可以很容易地将值注⼊这些组件属性中，并且可以细粒度地调整⾃动配置功能。\n配置属性并不专属于Spring创建的bean。\n如有遗漏或错误，欢迎补充纠正\n","date":"2022-12-14T00:00:00Z","image":"http://www.jansonblog.com/p/spring5/1_hu9741472974145540847.jpg","permalink":"http://www.jansonblog.com/p/spring5/","title":"Spring学习之路（五）"},{"content":"生活总结：\n那天我们都喝醉了，也都哭了，互相说了许多肝胆相照的话，真是难忘的一夜。\n2022——被“牢”日本的第三年 冬(ふゆ) 春(はる) 掘金 4月报名掘金青训营\n礼盒+周边 夏(なつ) 夏天，一个学长毕业了，也是山东人。生活和学习都给了我很多帮助。 外表冷酷坚强的学长，临别那天像个泪人。然后说好到最近车站送他，结果一直陪他坐电车坐了一个多小时，一直送到大阪站。\n那天离我表弟很近，包里带着一个钱包，坐了一个小时车去他家住了一个周，算不上是一次\u0026quot;说走就走的旅行\u0026quot;，但是也不知道怎么就突然离开自己的出租屋这么久。 秋(あき) 掘友们 最有收获的属于游戏圈组织的那一次王者荣耀比赛的活动了——抱着纯纯凑热闹的心理，找了个队混替补，结果发现群里的人全都很nice。\n队长是山东老乡，大概是当时圈子里唯一剩下的朋友了 2022年过去了，我很怀念它。\n","date":"2022-12-06T00:00:00Z","image":"http://www.jansonblog.com/p/2022/1_hu14147223280733868177.jpg","permalink":"http://www.jansonblog.com/p/2022/","title":"2022年总结"},{"content":" 本文是Spring Security系列最后一篇总结。\n对OAuth2.0的支持 OAuth2.0是什么？\n举个例子，就是网站中常见的第三方登录，登录某个网站支持使用Facebook，Google账号登录。微信网页授权也是基于OAuth2.0。同时1.0版本也已经被2.0完全取代了。\nSpring Security支持Fackbook,Google,GitHub,Okta第三方登录 书中没有详细的配置教学：“ 通过OAuth2/OpenID连接客户端，你需要设置以下属性:” 1 2 3 4 5 6 7 8 9 spring: security: oauth2: client: registration: \u0026lt;oauth2 or openid provider name\u0026gt;: clientId: \u0026lt;client id\u0026gt; clientSecret: \u0026lt;client secret\u0026gt; scope: \u0026lt;comma-separated list of requested scopes\u0026gt; 如果要启用OAuth2.0登录，需要在Spring Security配置类中添加.and().oauth2Login()方法。\n同时提供传统用户名-密码登录方式和第三方登录：.and().oauth2Login().loginPage(\u0026quot;/login\u0026quot;) 启用logout登出功能：\n1 2 3 4 5 6 7 /** * 启用logout登出:点击logout时，session被清空，同时登出 * logoutSuccessUrl()方法：登出后，重定向到指定路径页面 */ .and() .logout() .logoutSuccessUrl(\u0026#34;/\u0026#34;) 阻止跨站请求伪造 (CSRF:Cross-site request forgery)： Spring Security含有内置的CSRF保护，而且是默认启用的，所以只需确保应用程序提交的任何表单都包含一个名为_csrf的字段，该字段包含CSRF令牌。 Spring Security通过将CSRF令牌放在名为_csrf的请求属性中来简化这一点。因此，在一个Thymeleaf模板中，可以用下面的代码在一个隐藏字段中呈现CSRF令牌:\n\u0026lt;input type=\u0026quot;hidden\u0026quot; name=\u0026quot;_csrf\u0026quot; th:value=\u0026quot;${_csrf.token}\u0026quot;/\u0026gt; 如果使用Spring MVC表单标签库（Spring MVC’s JSP tag library）或spring security安全方言，内置CSRF令牌的隐藏字段会自动显示。 在静态模板Thymeleaf 中，只需要确保元素作为Thymeleaf的前缀，例如： \u0026lt;form method=\u0026quot;POST\u0026quot; th:action=\u0026quot;@{/login}\u0026quot; id=\u0026quot;loginForm\u0026quot;\u0026gt;，th:action 在Thymeleaf会为开发者渲染隐藏字段。 作者极其不推荐，但是还是教了这个歪门邪道：\n禁用内置CSRF支持：\n.and().csrf().disable() 方法级安全控制 @PreAuthorize注解 作用 @PreAuthorize注解根据SpEL表达式进行判断，如果表达式值为false，则不会调用方法： @PreAuthorize如果阻止了调用，SpringSecurity抛出AccessDeniedException未检查的异常，不需要进行捕捉。除非想对其进行自定义处理。如果不进行捕获: 异常会被SpringSecurity的过滤器捕捉，要么显示HTTP403错误； 要么如果用户没登录的话，被重定向到登录界面； 用法 1 2 3 4 @PreAuthorize(\u0026#34;hasRole(\u0026#39;ADMIN\u0026#39;)\u0026#34;) public void deleteAllOrders(){ orderRepository.deleteAll(); } 注意 在以前的用法中，使用@EnableGlobalMethodSecurity注解，并扩展WebSecurityConfigurerAdapter类并且覆盖配置HttpSecurity和WebSecurity的方法；\n现在，WebSecurityConfigurerAdapter在SpringSecurity5.7.1以上或SpringBoot2.7.0以上会出现已被弃用的警告!** 在新的用法中，我们得分别声明类型为SecurityFilterChain和WebSecurityCustomizer的bean，例如：\n1 2 3 4 5 6 7 8 @Bean public SecurityFilterChain filterChain(HttpSecurityhttp) throws Exception{ } @Bean public WebSecurityCustomizer webSecurityCustomizer(){ } @PostAuthorize注解 作用 @PostAuthorize注解的工作方式几乎与@PreAuthorize注解相同，只是它的表达式在调用目标方法并返回之前不会被计算。表达式可以根据方法的返回值来决定是否允许调用方法。\n抛出异常与@PreAuthorize注解相同，为AccessDeniedException未检查的异常。\n用法 1 2 3 4 5 @PostAuthorize(\u0026#34;hasRole(\u0026#39;ADMIN\u0026#39;) || \u0026#34; + \u0026#34;returnObject.user.username == authentication.name\u0026#34;) public TacoOrder getOrder(long id) { ... } Spring Security判断经过身份验证用户的方法： 方法一 在控制器方法中添加java.security.Principal对象： 1 2 3 4 5 6 7 8 @PostMapping public String processOrder(@Valid TacoOrder order, Errors errors, SessionStatus sessionStatus, Principal principal) { ... User user = userRepository.findByUsername(principal.getName());\torder.setUser(user); ... } 方法二 在控制器方法中添加org.springframework.security.core.Authentication对象： 1 2 3 4 5 6 7 8 9 10 11 12 /** * 调用getPrincipal()方法得到主要对象（例子为User） * getPrincipal()方法返回java.util.Object，所以将其转换为User */ @PostMapping public String processOrder(@Valid TacoOrder order, Errors errors, SessionStatus sessionStatus, Authentication authentication) { ... User user = (User) authentication.getPrincipal(); order.setUser(user); ... } 方法三 注入一个带@AuthenticationPrincipal注解的方法参数。（该注解来自Spring Security的org.springframework.security.core.annotation包）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @PostMapping public String processOrder(@Valid TacoOrder order, Errors errors, SessionStatus sessionStatus, @AuthenticationPrincipal User user) { if (errors.hasErrors()) { return \u0026#34;orderForm\u0026#34;; } order.setUser(user); orderRepo.save(order); sessionStatus.setComplete(); return \u0026#34;redirect:/\u0026#34;; } 优点： 不需要对对象进行映射 它将特定于安全性的代码限制为注释本身 方法四 还有另一种方法可以识别经过身份验证的用户是谁，虽然有点混乱，因为它使用了大量特定于安全的代码。可以从安全上下文中获取一个身份验证对象，然后像这样请求它的主体： 1 2 3 Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); User user = (User) authentication.getPrincipal(); 缺点： 有大量安全相关的代码 优点： 可以在应用程序中的任何地方使用，而不仅仅是在控制器的处理程序方法中。（这使得它适合在较低级别的代码中使用） 本章完\n如有遗漏或错误，欢迎补充纠正\n","date":"2022-11-16T00:00:00Z","image":"http://www.jansonblog.com/p/spring4/1_hu9741472974145540847.jpg","permalink":"http://www.jansonblog.com/p/spring4/","title":"Spring学习之路（四）"},{"content":"什么是并查集？ 并查集(Disjoint-set data structure)是一种数据结构，用于解决不交集问题的合并及查询问题。它还有几个英文名叫：Union-find data structure / merge–find set(中文就是：合并-查找数据结构)。\n为什么叫合并-查询数据结构？因为并查集有三个功能：\n添加 合并 查询 以维基百科的例子为例:\n现在有数字1-8共八个元素，每个元素是一个集合： 合并操作几次后，一些集合合并到了一起： 这就是并查集，其实很简单。其主要的作用就是合并和查找。\n其最常见的实现是不交集森林。但是为了方便解释，接下来用一个数组实现的力扣题目来说明。\n力扣990题 题目：等式方程的可满足性\n给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：\u0026ldquo;a==b\u0026rdquo; 或 \u0026ldquo;a!=b\u0026rdquo;。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。\n只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。\n示例1：\n输入： [\u0026ldquo;a==b\u0026rdquo;,\u0026ldquo;b!=a\u0026rdquo;]\n输出： false\n解释： 如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。\n示例2：\n输入： [\u0026ldquo;b==a\u0026rdquo;,\u0026ldquo;a==b\u0026rdquo;]\n输出： true\n解释： 我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。\n题解[Java] (感谢Lee215大佬提供的题解)： 990这道题由于最大只有26个小写字母，所以可以使用数组来实现并查集。\n具体思路（并查集的三个功能）：\n添加： 建立大小为26的int数组,名为uf；得到大小为26的数组，并让每个位置对应一个英文字母，即：\n从'a'-'z'对应uf[0] - uf[25]，即：uf[0] = 0，uf[1] = 1……uf[25]=25分别代表26个字母，也得到了26个集合。 合并： 将符合 ==关系的合并到一个集合中，实现：\n例如，我们想将'a'对应的集合uf[0]与'b'对应的集合uf[1]合并，只需让：uf[0] = 1\n这样当我们查看'a'对应的uf[0]的值时，即可发现集合'a'与集合'b'是合并的。 查找： 查找只需要从数组uf的一个位置开始，便可以知道该位置对应的字母与哪些字母合并过。 在建立并查集后，本题只需要查看所有!=关系中的字母，是否在并查集中被合并到了一个集合。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { int[] uf = new int[26]; public boolean equationsPossible(String[] equations) { //添加并查集；uf[0]到uf[25]分别对应从\u0026#39;a\u0026#39;到\u0026#39;z\u0026#39;的26个小写字母 for(int i = 0; i \u0026lt; 26; i++){ uf[i] = i; } //合并；合并“==”关系的字母：使用find()方法查询到集合的最后一个字母，将其合并 for(String s : equations){ if(s.charAt(1) == \u0026#39;=\u0026#39;){ uf[find(s.charAt(0) - \u0026#39;a\u0026#39;)] = find(s.charAt(3) - \u0026#39;a\u0026#39;); } } //遍历并查集，使用find()方法找到每个集合最尾端的字母， //判断最尾端字母是否相同来判断“!=”两边的字母是否位于一个集合内 for(String s : equations){ if(s.charAt(1) == \u0026#39;!\u0026#39;){ if(uf[find(s.charAt(0) - \u0026#39;a\u0026#39;)] == uf[find(s.charAt(3) - \u0026#39;a\u0026#39;)]) return false; } } return true; } //查找；寻找属于同一集合的最尾端的字母，将其返回 private int find(int idx){ if(uf[idx] != idx){ uf[idx] = find(uf[idx]); } return uf[idx]; } } 如有遗漏或错误，欢迎补充纠正\n","date":"2022-11-14T00:00:00Z","image":"http://www.jansonblog.com/p/union-find/1_hu6300381003025600420.jpg","permalink":"http://www.jansonblog.com/p/union-find/","title":"并查集（Union-find）[Java]"},{"content":"KMP(Knuth-Morris-Pratt)算法： 字符串查找算法（简称为KMP算法）可在一个字符串S内查找一个词W的出现位置。一个词在不匹配时本身就包含足够的信息来确定下一个匹配可能的开始位置，此算法利用这一特性以避免重重复查找之前出现的字符。\n我对MKP的认识：其归属于DP问题，核心的思想在于对要查找的字符串进行处理——寻找最长的前缀。然后通过记忆化数组的方式，跳过不可能成功匹配的字符串位置，从下一个可能的位置进行搜索。利用要查找字符串的特性，利用其前缀和后缀的共同部分来简化搜索过程。\n算法原理： 简单的暴力搜索无非就是从每个可能的index开始，与要查找的字符串进行比较。 而KMP则会跳过已经匹配的部分，以维基百科的说明为例，简单概括过程：\n要查找的字符串W=\u0026ldquo;ABCDABD\u0026rdquo;，\n给定字符串S=\u0026ldquo;ABC ABCDAB ABCDABCDABDE\u0026rdquo;\n为例说明查找过程：\nS: ABC ABCDAB ABCDABCDABDE\nW: ABCDABD\nS[3]（=\u0026rsquo; \u0026rsquo;)与W[3]（=\u0026lsquo;D\u0026rsquo;）不匹配，所以跳过；从S[4]开始，与W[0]进行比较。 S:ABC ABCDAB ABCDABCDABDE\nW:ABCDABD\n从S[4]开始比较，当位于S[10]（=\u0026rsquo; \u0026rsquo;）时，与W对应的字符不匹配；但是此时可以注意到，\u0026quot;AB\u0026ldquo;在“ABCDAB\u0026ldquo;的头尾处均有出现——这意味着，尾部的“AB”可以作为下一次比较的起点。 所以下次从index = 8的位置： S:ABC ABCDAB ABCDABCDABDE\nW:ABCDABD\n即A开始进行匹配。 应用题目实战: LeetCode 28. Find the Index of the First Occurrence in a String\n题目实战日后补充说明\n同时推荐一个算法可视化工具：\nalgorithm-visualizer_KMP\n如有遗漏或错误，欢迎补充纠正\n","date":"2022-11-03T00:00:00Z","image":"http://www.jansonblog.com/p/kmp/1_hu18271085003364396892.png","permalink":"http://www.jansonblog.com/p/kmp/","title":"KMP算法（字符串匹配算法）"},{"content":" Spring实战第五版中使用的WebSecurityConfigurerAdapter已被弃用 （还没学过就被弃用了\u0026hellip;） 第五章开始，使用最新的Spring实战第六版进行学习 Spring Security的密码编译器 密码编译器 加密方法 BCryptPasswordEncoder 应用 bcrypt 加强哈希加密 NoOpPasswordEncoder 不应用任何编码（对测试有用，不适合生产使用） Pbkdf2PasswordEncoder 应用 PBKDF2 加密 SCryptPasswordEncoder 应用 scrypt 哈希加密 StandardPasswordEncoder 应用 SHA-256 哈希加密（被认为不够安全，已经被弃用） 数据库中密码被加密；\n用户在login输入的密码使用相同的算法进行编码，在数据库使用PasswordEncoder的matches()方法进行比较。\nps：关于为什么认为StandardPasswordEncoder是不安全的：\n目前有说法是认为SHA-256不够安全，因为SHA-256算法本身效率高，速度快，所以暴力破解门槛低。\n而bcrypt算法可以通过参数调节计算速度，计算速度慢，所以大幅提高了暴力破解的门槛，安全性也就高了\n（但是目前SHA-256还未被成功破解过……？\nUserDetailsService实现： Spring Security提供了几个开箱即用的UserDetailsService实现：\n基于内存的用户存储 基于JDBC的用户存储 由LDAP支持的用户存储 1 2 3 4 5 6 7 8 9 /* *loadUserByUsername()方法接受用户名并使用它查找UserDetails对象。 *如果找不到给定用户名的用户，则抛出UsernameNotFoundException异常。 */ public interface UserDetailsService { UserDetails loadUserByUsername(String username) throws UsernameNotFoundException; } Securing web requests authorizeRequests()返回(ExpressionUrlAuthorizationConfigurer.ExpressionInterceptUrlRegistry)对象，允许指定URL路径和模式，以及路径对应的安全要求：\n书中项目的代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* *保证对于/design 和 /orders路径的请求只对认证的用户有效； *其他路径对于所有的用户有效； */ @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { return http .authorizeRequests() .antMatchers(\u0026#34;/design\u0026#34;, \u0026#34;/orders\u0026#34;).hasRole(\u0026#34;USER\u0026#34;) .antMatchers(\u0026#34;/\u0026#34;, \u0026#34;/**\u0026#34;).permitAll() .and() .build(); } Spring web requests的配置方法，以及如何保护路径如下：\n方法 作用 access(String) 如果给定的Spring Expression Language(SpEL)表达式求值为true，允许访问 anonymous() 允许匿名用户访问 authenticated() 允许通过验证的用户访问 denyAll() 无条件拒绝所有访问 fullyAuthenticated() 允许通过完全身份验证的用户访问（不推荐） hasAnyAuthority(String\u0026hellip;) 如果用户具有任何一个给定的权限，则允许访问（可代替hasAnyRole(String)方法） hasAnyRole(String…) 如果用户具有任何给定的角色，则允许访问 （自动加 ROLE_ 的前缀） hasAuthority(String) 如果用户具有指定的权限，则允许访问 hasRole(String) 如果用户具有指定的角色，则允许访问 hasIpAddress(String) 如果用户具有指定的IP地址，则允许访问 not() 否定任何其他认证方法的效果 permitAll() 无条件允许访问 rememberMe() 允许通过 remember-me 进行身份验证的用户访问 这其中值得注意的事，hasRole()方法可以被hasAuthority()代替：hasRole()方法自动补足 ROLE_ 的前缀。 设计上来看，一个是权限，一个是角色，角色是权限的集合体。 Spring Security对于SpEL表达式的扩展 Security expression SpEL的计算结果 authentication 用户的认证对象 denyAll 恒为false hasAnyAuthority(String\u0026hellip;authorities) 如果用户被授予所有权限中的某一个，则为true hasAnyRole(String\u0026hellip;roles) 如果用户有给定的roles中的某一个，则为true hasAnyAuthority(String authority) 如果用户被授予指定的权限，则为true hasPermission(Object target, Object permission) 如果用户能以给定的权限访问指定的目标对象，则为true hasRole(String role) 如果用户有给定的role，则为true hasIpAddress(String ipAddress) 如果请求来自指定ip，则为true isAnnoymous() 如果用户是匿名的，则为true isAuthenticated() 如果用户已认证，则为true isFullyAuthenticated() 如果用户经过完全身份验证(没有使用remember-me进行身份验证)，则为true isRememberMe() 如果用户使用remeber-me进行身份验证，则为true permitAll() 恒为true principal 用户的主要对象 remember-me（记住我）认证，就是常见的记住我：下次登录时，使用cookie导致自动登录发生。 1 2 3 4 5 6 7 8 9 10 11 12 13 /* *所以上面一节中的方法，可以用access()方法+security表达式的方式来实现； */ @Bean public SecurityFilterChain filterChain(HttpSecurity http) throws Exception { return http .authorizeRequests() .antMatchers(\u0026#34;/design\u0026#34;, \u0026#34;/orders\u0026#34;).access(\u0026#34;hasRole(\u0026#39;USER\u0026#39;)\u0026#34;) .antMatchers(\u0026#34;/\u0026#34;, \u0026#34;/**\u0026#34;).access(\u0026#34;permitAll()\u0026#34;) .and() .build(); } 如有遗漏或错误，欢迎补充纠正\n","date":"2022-11-02T00:00:00Z","image":"http://www.jansonblog.com/p/spring3/1_hu9741472974145540847.jpg","permalink":"http://www.jansonblog.com/p/spring3/","title":"Spring学习之路（三）"},{"content":"近况 两个月没有更新博客，把最近的一些事，漫无目的的记录下来。\n1.力扣 力扣依旧在每日刷题，现在基本上看到题可以判断出是什么题型，但是最近对于做题仿佛失去了一些思考。明知道只做出来是不对的，但是还是懒得去思考。或许是因为研究过于不顺，导致自己每天没有余力去探索。\n跟狗人和阿毛一起报名了力扣的一个什么比赛，六道题目，好像一个人四个小时。我和阿毛10分钟不到做完了1，2题，后面知道是dp但是没想出公式，加上那天后背的粉瘤爆炸，下午不得不赶在医院关门前去诊所，最后排名也就只能1000+的样子。\n好消息：比赛赚了1k积分，能换力扣全家桶了。\n2.学习 LoRa网关真的很难搞，研究室没有人能帮，只能自己硬着头皮，顶着压力一点一点来。\n今天抱着试试的态度跟一个台湾的公司联络了一下，居然一个小时就收到了回信，虽然很简短，但是给了看起来有用的文档。看了一眼文档，前路漫漫，比想象中的要困难。进度一拖再拖，没有进展。\n3.掘金 最大的收获应该是认识了掘金的小伙伴。安安，小安，小鱼，鑫，master。一个很不错的小圈子。\n其中印象最深，聊的最多的是安安。安安是莱州的老乡。安安看着外表搞笑坚强，但是自述有些抑郁。我呢？我应该并不抑郁，不过在日本留学这几年，我内心也是孤独的，我似乎能体会到她和阿毛当时考研时的孤独。她的经历我周围有很多人跟她相似，但是她是一个非常外向的人，内心痛苦会释放。\n4.独白 安安是一个让我有时候会羡慕的人，因为她知道自己喜欢什么。而我，像王小波说的那样，原文我并不记得了，大概意思是：20岁是最迷茫的年龄，因为一个人要决定自己以后做什么。\n我又想做什么呢？自学了Java或许是出于一种喜爱，又或是承诺的履行？因为好像是有人跟我说可以学Java，但是我可能又是羡慕大一花旗那个保研清北的学长，因为在他口中Java是那么有趣。或许我确实对Java 有自己的喜爱，才能在尝试过那么多语言后选择Java。\n总之，想起来一个亲戚跟我说的话：“现在的年轻人迷茫是因为可以选的路太多了，她们那个年代，没有那么多路，大家不知不觉进了一条路就坚持走到了最后”。所以尽量不去想自己的选择，做出了选择就不要后悔。\n","date":"2022-10-20T00:00:00Z","image":"http://www.jansonblog.com/p/2022-10/1_hu860817414138689066.jpg","permalink":"http://www.jansonblog.com/p/2022-10/","title":"2022年10月20日"},{"content":"毕业季 学长要去LINE福冈工作了，走之前前一夜只睡了2个两小时，看着那状态实在不放心，陪他坐车到了新大阪去换乘新干线（最后还是等错了站台，改了票…）\n那会我跟学长都很喜欢吃咖喱\nflag！ 跟学长约定，我拿到offer或者回国之前一定会去福冈找他。\n用了很久的头像，是福冈县神社的照片\n大阪万博纪念公园 在送学长去大阪的路上临时决定要去大阪的表弟家玩几天，表弟刚考完阪大修士，也算是说走就走的旅行了。 天王寺——あべのハルカス 天王寺的「あべのハルカス」是现在关西最高的ビル，入门券1500。\n看了个日落和夜景。\n之前研究室日本人曾经跟我说过，大阪北部和南部差别很大，南边犯罪率高，治安很差\n北边高楼耸立，南边除了几个大型公园，几乎没有高层建筑(照片可能拍的位置不太对）\n非常经典的一幕，天王寺动物园车站北侧有一个看着很怪的会馆，应该是基督教会馆，但这外观看着像个邪教…\n车站南侧更诡异，走过来的时候路上很吓人，照片都没好意思拍，也可能那边的人看着吓人吧。不过在动物园周围看到了很多涂鸦的垃圾箱和流浪汉…在日本有涂鸦的话，治安应该是很差的…\n小动物 姬路城 最后一天去了姬路城，路上有一段靠海，风景很不错\n姬路城确实比关西其他城堡好玩很多\n不愿清醒，宁愿一直沉迷放纵。不知归路，宁愿一世无悔追逐。\n","date":"2022-08-25T00:00:00Z","image":"http://www.jansonblog.com/p/2022-08/title_hu13292875734077721679.jpg","permalink":"http://www.jansonblog.com/p/2022-08/","title":"2022年8月生活日记"},{"content":"模板引擎 书中总结了以下模板：\n模板 Spring Boot starter依赖 JavaServer Pages(JSP) 无(由Tomcat或Jetty提供) FreeMarker spring-boot-starter-freemarker Groovy Templates spring-boot-starter-groovy-templates Mustache spring-boot-starter-mustache Thymeleaf spring-boot-starter-thymeleaf 其中，JSP不需要依赖的原因:\n是因为Servlet容器本身（默认是Tomcat）会实现JSP，因此不需要额外的依赖。 使用JSP问题：\nJava Servlet容器包括嵌入式的Tomcat和Jetty容器，通常会在“/WEB-INF”目录下寻找JSP。如果将应用构建成一个可执行的JAR文件，就无法满足这种需求；只有在将应用构建成WAR文件并部署到Servlet容器中时，才能选择JSP方案。 模板缓存 默认情况下，模板只有在第⼀次使用的时候解析⼀次，解析的结果会被后续的请求所使⽤。开发期缓存存在时，想要看到变更效果，必须重新启动应用，非常不方便 禁用模板缓存：将相关缓存属性设成false:在application.properties中添加： spring.thymeleaf.cache=false 模板 启用缓存的属性 FreeMarker spring.freemarker.cache Groovy Templates spring.groovy.template.cache Mustache spring.mustache.cache Thymeleaf spring.thymeleaf.cache Thymeleaf模板 Thymeleaf 模板只是 HTML 与一些额外的元素属性，指导模板在渲染请求数据。\n例如，如果有一个请求属性，它的键是 “message”，你希望它被Thymeleaf渲染成一个HTML\u0026lt;p\u0026gt;标签，你可以在你的Thymeleaf模板中写以下内容：\n\u0026lt;p th:text=\u0026quot;${message}\u0026quot;\u0026gt;placeholder message\u0026lt;/p\u0026gt;\nThymeleaf 提供了一个内置的field.hasErrors方法，该方法根据给定字段是否存在任何错误返回一个布尔值。\n例如要在一个信用卡号字段上显示验证错误：\n\u0026lt;label for=\u0026quot;ccNumber\u0026quot;\u0026gt;Credit Card #: \u0026lt;/label\u0026gt;·\n\u0026lt;input type=\u0026quot;text\u0026quot; th:field=\u0026quot;*{ccNumber}\u0026quot;/\u0026gt;\n\u0026lt;span class=\u0026quot;validationError\u0026quot; th:if=\u0026quot;${#fields.hasErrors('ccNumber')}\u0026quot; th:errors=\u0026quot;*{ccNumber}\u0026quot;\u0026gt;CC Num Error\u0026lt;/span\u0026gt;\n如有遗漏或错误，欢迎补充纠正\n","date":"2022-08-15T00:00:00Z","image":"http://www.jansonblog.com/p/spring2/1_hu9741472974145540847.jpg","permalink":"http://www.jansonblog.com/p/spring2/","title":"Spring学习之路（二）"},{"content":"前言 学习路程是按照Spring实战（第五版）进行，本系列只针对笔者自己进行内容总结，用于加深学习以及日后回顾使用。如感兴趣，推荐阅读参考图书进行学习。\n书中有较多地方描述比较不清楚，实战时，存在很多问题。spring-in-action-5-samples对书中每一章项目进行了汇总，对照此仓库学习更容易理解。\nSpring项目结构 mvnw和mvnw.cmd：这是Maven包装器（wrapper）脚本，借助脚本，即使没有安装Maven也可以构建项目 pom.xml： Maven构建规范，用于引入依赖等 Application.java：SpringBoot主类 application.properties：初始为空，用来指定配置属性 static：初始为空，用于存放静态内容（图片，样式表，JavaScript等） templates：初始为空，用于存放渲染内容到浏览器的模板文件 ApplicationTests.java：简单的测试类，确保Spring应用上下文成功加载 @SpringBootApplication组合注解 @SpringBootApplication是一个组合注解，它组合了3个其他的注释：\n@SpringBootConfiguration：将该类声明为配置类。尽管这个类⽬前还没有太多的配置，但是后续我们可以按需添加基于Java的Spring框架配置。这个注解实际上是@Configuration注解的特殊形式。 @EnableAutoConfiguration：启⽤Spring Boot的⾃动配置。我们随后会介绍⾃动配置的更多功能。就现在来说，我们只需要知道这个注解会告诉Spring Boot⾃动配置它认为我们会⽤到的组件。 @ComponentScan：启⽤组件扫描。这样我们能够通过像@Component、 @Controller、@Service这样的注解声明其他类，Spring会⾃动发现它们并将它们注册为Spring应⽤上下⽂中的组件 Spring的一些重点项目： Spring MVC——Spring的Web框架：可以边写控制器处理Web请求；创建REST API，生成非HTML的输出 Spring Boot：starter依赖和自动配置；Actuator能洞察应用运行时的内部工作状况；灵活的环境属性规范；在核心框架的测试辅助功能之上提供了对测试的额外支持 Spring Data：将应用程序数据repository定义为java接口，定义驱动存储和检索数据的方法时使用一种命名约定即可；能够处理不同类型的数据库，包括关系型数据库（JPA）、文档数据库（Mongo）、图数据库（Neo4j）等 Spring Security：Spring的安全框架，解决了身份验证、授权和API安全性等安全性需求 Spring Integration：解决实时集成问题，数据在可用时马上就会得到处理 Spring Batch：批处理集成问题——数据收集一段时间，直到触发触发器，才进行批处理 Spring Cloud：使用Spring开发云原生应用程序的项目 如有遗漏或错误，欢迎补充纠正\n","date":"2022-08-13T00:00:00Z","image":"http://www.jansonblog.com/p/spring1/1_hu9741472974145540847.jpg","permalink":"http://www.jansonblog.com/p/spring1/","title":"Spring学习之路（一）"},{"content":"基本操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 git init // 初始化仓库，生成.git目录 git status // 查看仓库的状态，显示目前分支，以及有没有可疑提交的内容 git add 要添加的文件 // 向暂存区添加文件 git commit // 执行启动编辑器，可以记述更加详细的信息 git commit -m \u0026#34;本次的提交注释\u0026#34;// 添加对提交的概述； git commit --amend // 修改上一条提交信息 git log // 查看提交日志 git log --pretty=short // 显示第一行简述信息 git log 文件名或目录名 //显示指定文件的日志 git log -p // 查看提交带来的变动，显示文件前后差别 git log -p 文件名或目录名 //查看指定文件的变动 git reflog // 查看当前仓库执行过的操作的日志 git diff // 查看当前工作树与暂存区的差别 git diff HEAD // 查看与最新提交的差别，在git commit前执行这条命令是个好习惯 分支的操作 1 2 3 4 5 6 7 8 9 10 11 12 git branch // 显示分支一览表 git checkout -b 新分支名 // 创建并切换到新的分支； /以上命令与“git branch 新分支名”，再执行“git git checkout 新分支名”效果相同/ git checkout 分支名 // 切换到分支 git checkout - // 切换到上一个分支 git merge // 合并分支 git merge --no-ff A // 将分支A合并到当前分支，并启动编辑器录入合并提交的信息 git log --graph // 以图表形式查看分支 更改提交的操作 1 2 3 4 /使用git reflog 查看仓库日志，第一列为时间哈希值/ git reset // 回溯历史版本 git reset --hard 目标时间点的哈希值 // 恢复到时间点的状态， 推送至远程仓库 1 2 3 4 5 6 7 8 9 // 将远程仓库的名称设置为origin（标识符） git remote add origin git@github.com:用户名/git-tutorial.git git remote -v // 查看当前远程仓库 git push // 推送至远程仓库 git push -u origin master // 将当前分支内容推送给远程仓库origin的master分支； // -u参数在推送的同时，将origin仓库的master分支设置为本地仓库当前分支的upstream（上游）, // 运行git pull 命令，本地仓库的这个分支可以直接从origin的master分支获取内容 从远程仓库获取 1 2 3 4 git clone // 将github仓库clone到本地，注意不要与之前操作的仓库在同一目录下 git checkout -b A origin/A //以远程仓库分支A为来源，在本地新建分支A git pull // 获取最新的远程仓库分支 其他深入理解Git的资料 Pro Git (零基础的git学习资料) LearnGitBranching (学习git基本操作的网站) tryGit (只有英文版的网站) 如有遗漏或错误，欢迎补充纠正\n","date":"2022-08-09T00:00:00Z","image":"http://www.jansonblog.com/p/git/git_hu12215723505164130046.jpg","permalink":"http://www.jansonblog.com/p/git/","title":"如何使用git"},{"content":"美景 研究室那些事儿 又吃啥了 生活 祝你今天愉快，你明天的愉快留着我明天再祝。\n","date":"2022-08-04T00:00:00Z","image":"http://www.jansonblog.com/p/2022-07/1_hu4579421403834086388.jpg","permalink":"http://www.jansonblog.com/p/2022-07/","title":"2022年7月散记"},{"content":"动态规划实现有两种方法：\n自下而上 (制表) 自上而下 (记忆化) 自下而上 自下而上是通过 迭代 实现的\n以斐波那契数列为例，F(0)=0, F(1)=1。通过F(0)和F(1)计算F(2)，然后使用计算结果计算F(3)…\n以此类推，一直计算F(n)\n1 2 3 4 5 6 7 // 伪代码如下: F = array of length (n + 1) F[0] = 0 F[1] = 1 for i from 2 to n: F[i] = F[i - 1] + F[i - 2] 自上而下 自上而下通过 递归 实现，并且通过 记忆化 提高效率(之后解释记忆化概念)\n如果我们想知道斐波那契数列F(n)，需要找到F(n-1)和F(n-2)…通过递归求出F(0)和F(1)\n缺点也很明显，在计算中存在大量的 重复计算 ，导致效率不高\n而解决方法也很简单，用空间换时间，也就是 记忆化 ：将函数调用的结果存储在哈希图或数组中，这样当再次进行相同的函数调用时，我们可以简单地返回记忆的结果，而不是重新计算结果。\n1 2 3 4 5 6 7 8 9 //伪代码如下: memo = hashmap Function F(integer i): if i is 0 or 1: return i if i doesn\u0026#39;t exist in memo: memo[i] = F(i - 1) + F(i - 2) return memo[i] 总结 所以，这两个算法哪个更好呢？\nDP(动态规划问题)可以用任意一种方法实现\n每个方法都有一个突出的优点:\n自下而上的运行速度更快 (递归效率低) 自上而下的实现更简单 (因为对于递归来说，我们不用在意子问题的逻辑顺序，而对于自下而上的方法来说，我们需要解决子问题的逻辑顺序) 比较简单而且经典的题目：《力扣 62.不同路径》\n学习资料如下:\nExplore - LeetCode\n如有遗漏或错误，欢迎补充纠正\n","date":"2022-05-27T00:00:00Z","image":"http://www.jansonblog.com/p/dp/PascalTriangleFibanacci_hu12437333451547199454.jpg","permalink":"http://www.jansonblog.com/p/dp/","title":"动态规划(Dynamic programming)问题解法"}]